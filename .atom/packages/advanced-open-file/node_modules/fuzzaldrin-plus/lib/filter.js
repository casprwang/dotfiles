(function() {
  var PathSeparator, legacy_scorer, pluckCandidates, scorer, sortCandidates;

  scorer = require('./scorer');

  legacy_scorer = require('./legacy');

  pluckCandidates = function(a) {
    return a.candidate;
  };

  sortCandidates = function(a, b) {
    return b.score - a.score;
  };

  PathSeparator = require('path').sep;

  module.exports = function(candidates, query, _arg) {
    var allowErrors, bAllowErrors, bKey, candidate, coreQuery, key, legacy, maxInners, maxResults, prepQuery, queryHasSlashes, score, scoredCandidates, spotLeft, string, _i, _j, _len, _len1, _ref;
    _ref = _arg != null ? _arg : {}, key = _ref.key, maxResults = _ref.maxResults, maxInners = _ref.maxInners, allowErrors = _ref.allowErrors, legacy = _ref.legacy;
    scoredCandidates = [];
    spotLeft = (maxInners != null) && maxInners > 0 ? maxInners : candidates.length;
    bAllowErrors = !!allowErrors;
    bKey = key != null;
    prepQuery = scorer.prepQuery(query);
    if (!legacy) {
      for (_i = 0, _len = candidates.length; _i < _len; _i++) {
        candidate = candidates[_i];
        string = bKey ? candidate[key] : candidate;
        if (!string) {
          continue;
        }
        score = scorer.score(string, query, prepQuery, bAllowErrors);
        if (score > 0) {
          scoredCandidates.push({
            candidate: candidate,
            score: score
          });
          if (!--spotLeft) {
            break;
          }
        }
      }
    } else {
      queryHasSlashes = prepQuery.depth > 0;
      coreQuery = prepQuery.core;
      for (_j = 0, _len1 = candidates.length; _j < _len1; _j++) {
        candidate = candidates[_j];
        string = key != null ? candidate[key] : candidate;
        if (!string) {
          continue;
        }
        score = legacy_scorer.score(string, coreQuery, queryHasSlashes);
        if (!queryHasSlashes) {
          score = legacy_scorer.basenameScore(string, coreQuery, score);
        }
        if (score > 0) {
          scoredCandidates.push({
            candidate: candidate,
            score: score
          });
        }
      }
    }
    scoredCandidates.sort(sortCandidates);
    candidates = scoredCandidates.map(pluckCandidates);
    if (maxResults != null) {
      candidates = candidates.slice(0, maxResults);
    }
    return candidates;
  };

}).call(this);
