'use strict';

/*global atom*/
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
const CompositeDisposable = require('atom').CompositeDisposable;

// This Class is repsonsible for creating a new Tagged Template grammar
// on detection of a changed Tagged Template Configuration in the package settings
module.exports = class CreateTtlGrammar {

  constructor() {
    let observeConfig = arguments.length <= 0 || arguments[0] === undefined ? false : arguments[0];
    this.disposable = new CompositeDisposable();
    this.configChangedTimer = null;
    this.TTLSCOPENAME = `languagebabel.ttlextension`;

    if (observeConfig) {
      // look for changes in tagged template handlers
      this.disposable.add(atom.config.observe('language-babel.taggedTemplateGrammar', this.observeTtlConfig.bind(this, 10000)));
    }
  }

  destroy() {
    this.disposable.dispose();
  }

  // add new grammars to registry
  addGrammars(filename) {
    return new Promise((resolve, reject) => {
      atom.grammars.loadGrammar(filename, err => {
        if (err) {
          reject(new Error(`Unable to add Grammar to registry\n${ filename }`));
        } else resolve();
      });
    });
  }

  // Check if the grammar exists under this SHA256 file name
  // If not then remove all ttl grammars and create a new one
  // This returns a Promise that resolves  with a ttl filename
  // if a new grammar was created or rejects if a problem.
  createGrammar(_ref) {
    let ttlFilename = _ref.ttlFilename;
    let ttlFilenameAbsolute = _ref.ttlFilenameAbsolute;
    let grammarText = _ref.grammarText;

    return new Promise((resolve, reject) => {
      this.doesGrammarFileExist(ttlFilename).then(ifFileExists => {
        if (ifFileExists) {
          resolve();
        } else {
          this.removeGrammars();
          this.removeTtlLanguageFiles().then(() => this.createGrammarFile(ttlFilenameAbsolute, grammarText)).then(() => this.addGrammars(ttlFilenameAbsolute)).then(() => {
            atom.notifications.addInfo('language-babel', { detail: `Grammar created at \n${ ttlFilenameAbsolute }`, dismissable: true });
            resolve(ttlFilename);
          }).catch(err => {
            atom.notifications.addWarning('language-babel', { detail: `${ err.message }`, dismissable: true });
            reject(err);
          });
        }
      });
    });
  }

  // write the ttl grammar file for this config
  createGrammarFile(filename, text) {
    return new Promise((resolve, reject) => {
      fs.writeFile(filename, text, err => {
        if (err) reject(new Error(err));else resolve();
      });
    });
  }

  // create a Grammar file's JSON text
  createGrammarText() {
    return `{
  "comment": "Auto generated Tag Extensions for language-babel",
  "comment": "Please do not edit this file directly",
  "scopeName": "${ this.TTLSCOPENAME }",
  "fileTypes": [],
  "patterns": [
    ${ this.getTtlConfig().map(ttlString => this.createGrammarPatterns(ttlString)) }
  ]
}`;
  }

  // Create a grammar's pattern derived from a the tagged template string
  // in the form matchString:includeScope
  createGrammarPatterns(ttlString) {
    let lastColonIndex = ttlString.lastIndexOf(':');
    let matchString = ttlString.substring(0, lastColonIndex);
    let includeScope = ttlString.substring(lastColonIndex + 1);
    const isValidIncludeScope = /^([a-zA-Z]\w*\.?)*(\w#([a-zA-Z]\w*\.?)*)?\w$/;

    if (matchString.length < 1 || !isValidIncludeScope.test(includeScope)) {
      throw new Error(`Error in the Tagged Template Grammar String ${ ttlString }`);
    }

    if (/^\".*\"$/.test(matchString)) {
      // Found a possible regexp in the form "regex" so strip the "
      // This is a oniguruma regex but we will do a simple JS regex test for
      // validity as it is most likely close enough!
      matchString = matchString.substring(1, matchString.length - 1);
      try {
        // the regex shouldn't have a single slash except before a "
        if (/\\[^"]/g.test(matchString.replace(/\\\\/g, ""))) {
          throw true;
        }
        // convert \anychar to anychar;
        new RegExp(matchString.replace(/\\([^\\])/g, "$1"));
      } catch (err) {
        throw new Error(`You entered an badly formed RegExp in the Tagged Template Grammar settings.\n${ matchString }`);
      }
    } else if (/"/g.test(matchString)) {
      throw new Error(`Bad literal string in the Tagged Template Grammar settings.\n${ matchString }`);
    } else {
      const escapeStringRegExp = /[|\\{}()[\]^$+*?.]/g;
      // Get a valid regexp escaped string. e.g. '/** @html */' -> '\/\*\* @html \*\/'
      matchString = matchString.replace(escapeStringRegExp, '\\\\$&');
    }

    return `{
      "contentName": "meta.ttl-grammar.js",
      "begin": "\\\\s*+(${ matchString })\\\\s*(\`)",
      "beginCaptures": {
        "1": { "name": "entity.name.tag.js" },
        "4": { "name": "punctuation.definition.quasi.begin.js" }
      },
      "end": "\\\\s*(?<!\\\\\\\\)(\`)",
      "endCaptures": {
        "1": { "name": "punctuation.definition.quasi.end.js" }
      },
      "patterns": [
        { "include": "source.js.jsx#literal-quasi-embedded" },
        { "include": "${ includeScope }" }
      ]
    }`;
  }

  // checks a ttl grammar filename exists
  // returns a Promise that resolves to true if ttlFileName exists
  doesGrammarFileExist(ttlFilename) {
    return new Promise(resolve => {
      fs.access(this.makeTtlGrammarFilenameAbsoulute(ttlFilename), fs.F_OK, err => {
        err ? resolve(false) : resolve(true);
      });
    });
  }

  // get full path to the language-babel grammar file dir
  getGrammarPath() {
    return path.normalize(path.resolve(atom.packages.loadedPackages['language-babel'].path, './grammars'));
  }

  // get an array of all language-babel grammar files
  getGrammarFiles() {
    return new Promise((resolve, reject) => {
      fs.readdir(this.getGrammarPath(), (err, data) => {
        if (err) reject(new Error(err));else {
          resolve(data);
        }
      });
    });
  }

  // read configurations for tagged templates
  getTtlConfig() {
    return atom.config.get('language-babel').taggedTemplateGrammar;
  }

  // get an array of grammar tagged template extension filenames
  getTtlGrammarFiles() {
    return this.getGrammarFiles().then(dirFiles => dirFiles.filter(function (filename) {
      return (/^ttl-/.test(filename)
      );
    }));
  }

  // generate a SHA256 for some text
  generateTtlSHA256(stringToHash) {
    let hash = crypto.createHash('sha256');
    hash.update(stringToHash);
    return hash.digest('hex');
  }

  // tagged template filename
  makeTtlGrammarFilename(hashString) {
    return `ttl-${ hashString }.json`;
  }

  // get a fully qualified filename
  makeTtlGrammarFilenameAbsoulute(ttlFilename) {
    return path.resolve(this.getGrammarPath(), ttlFilename);
  }

  // observe changes in the taggedTemplateGrammar config which take place
  // because observed config changes are fired as a user types them inside
  // settings we need to delay processing the array strings, until last char
  // entered was setTimeout seconds ago. parse tagged template configuration
  // and then create grammar and generate a SHA256 hash from the grammar
  observeTtlConfig(timeout) {
    if (this.configChangedTimer) clearTimeout(this.configChangedTimer);
    this.configChangedTimer = setTimeout(() => {
      try {
        const grammarText = this.createGrammarText();
        const hash = this.generateTtlSHA256(grammarText);
        const ttlFilename = this.makeTtlGrammarFilename(hash);
        const ttlFilenameAbsolute = this.makeTtlGrammarFilenameAbsoulute(ttlFilename);
        this.createGrammar({ ttlFilename, ttlFilenameAbsolute, grammarText });
      } catch (err) {
        atom.notifications.addWarning('language-babel', { detail: `${ err.message }`, dismissable: true });
      }
    }, timeout);
  }

  // Remove grammars before upodating
  removeGrammars() {
    atom.grammars.removeGrammarForScopeName(this.TTLSCOPENAME);
  }

  // remove all language files in tagged template GrammarFiles array
  removeTtlLanguageFiles() {
    return this.getTtlGrammarFiles().then(ttlGrammarFiles => {
      for (let ttlGrammarFilename of ttlGrammarFiles) {
        let ttlGrammarFileAbsoulte = this.makeTtlGrammarFilenameAbsoulute(ttlGrammarFilename);
        fs.unlink(ttlGrammarFileAbsoulte);
      }
    });
  }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImNyZWF0ZS10dGwtZ3JhbW1hci5qcyJdLCJuYW1lcyI6WyJjcnlwdG8iLCJyZXF1aXJlIiwiZnMiLCJwYXRoIiwiQ29tcG9zaXRlRGlzcG9zYWJsZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJDcmVhdGVUdGxHcmFtbWFyIiwiY29uc3RydWN0b3IiLCJvYnNlcnZlQ29uZmlnIiwiZGlzcG9zYWJsZSIsImNvbmZpZ0NoYW5nZWRUaW1lciIsIlRUTFNDT1BFTkFNRSIsImFkZCIsImF0b20iLCJjb25maWciLCJvYnNlcnZlIiwib2JzZXJ2ZVR0bENvbmZpZyIsImJpbmQiLCJkZXN0cm95IiwiZGlzcG9zZSIsImFkZEdyYW1tYXJzIiwiZmlsZW5hbWUiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImdyYW1tYXJzIiwibG9hZEdyYW1tYXIiLCJlcnIiLCJFcnJvciIsImNyZWF0ZUdyYW1tYXIiLCJ0dGxGaWxlbmFtZSIsInR0bEZpbGVuYW1lQWJzb2x1dGUiLCJncmFtbWFyVGV4dCIsImRvZXNHcmFtbWFyRmlsZUV4aXN0IiwidGhlbiIsImlmRmlsZUV4aXN0cyIsInJlbW92ZUdyYW1tYXJzIiwicmVtb3ZlVHRsTGFuZ3VhZ2VGaWxlcyIsImNyZWF0ZUdyYW1tYXJGaWxlIiwibm90aWZpY2F0aW9ucyIsImFkZEluZm8iLCJkZXRhaWwiLCJkaXNtaXNzYWJsZSIsImNhdGNoIiwiYWRkV2FybmluZyIsIm1lc3NhZ2UiLCJ0ZXh0Iiwid3JpdGVGaWxlIiwiY3JlYXRlR3JhbW1hclRleHQiLCJnZXRUdGxDb25maWciLCJtYXAiLCJ0dGxTdHJpbmciLCJjcmVhdGVHcmFtbWFyUGF0dGVybnMiLCJsYXN0Q29sb25JbmRleCIsImxhc3RJbmRleE9mIiwibWF0Y2hTdHJpbmciLCJzdWJzdHJpbmciLCJpbmNsdWRlU2NvcGUiLCJpc1ZhbGlkSW5jbHVkZVNjb3BlIiwibGVuZ3RoIiwidGVzdCIsInJlcGxhY2UiLCJSZWdFeHAiLCJlc2NhcGVTdHJpbmdSZWdFeHAiLCJhY2Nlc3MiLCJtYWtlVHRsR3JhbW1hckZpbGVuYW1lQWJzb3VsdXRlIiwiRl9PSyIsImdldEdyYW1tYXJQYXRoIiwibm9ybWFsaXplIiwicGFja2FnZXMiLCJsb2FkZWRQYWNrYWdlcyIsImdldEdyYW1tYXJGaWxlcyIsInJlYWRkaXIiLCJkYXRhIiwiZ2V0IiwidGFnZ2VkVGVtcGxhdGVHcmFtbWFyIiwiZ2V0VHRsR3JhbW1hckZpbGVzIiwiZGlyRmlsZXMiLCJmaWx0ZXIiLCJnZW5lcmF0ZVR0bFNIQTI1NiIsInN0cmluZ1RvSGFzaCIsImhhc2giLCJjcmVhdGVIYXNoIiwidXBkYXRlIiwiZGlnZXN0IiwibWFrZVR0bEdyYW1tYXJGaWxlbmFtZSIsImhhc2hTdHJpbmciLCJ0aW1lb3V0IiwiY2xlYXJUaW1lb3V0Iiwic2V0VGltZW91dCIsInJlbW92ZUdyYW1tYXJGb3JTY29wZU5hbWUiLCJ0dGxHcmFtbWFyRmlsZXMiLCJ0dGxHcmFtbWFyRmlsZW5hbWUiLCJ0dGxHcmFtbWFyRmlsZUFic291bHRlIiwidW5saW5rIl0sIm1hcHBpbmdzIjoiOztBQUFBO0FBQ0EsTUFBTUEsU0FBU0MsUUFBUSxRQUFSLENBQWY7QUFDQSxNQUFNQyxLQUFLRCxRQUFRLElBQVIsQ0FBWDtBQUNBLE1BQU1FLE9BQU9GLFFBQVEsTUFBUixDQUFiO0FBQ0EsTUFBTUcsc0JBQXNCSCxRQUFRLE1BQVIsRUFBZ0JHLG1CQUE1Qzs7QUFFQTtBQUNBO0FBQ0FDLE9BQU9DLE9BQVAsR0FDQSxNQUFNQyxnQkFBTixDQUF1Qjs7QUFNckJDLGdCQUFtQztBQUFBLFFBQXZCQyxhQUF1Qix5REFBUCxLQUFPO0FBQUEsU0FKbkNDLFVBSW1DLEdBSnRCLElBQUlOLG1CQUFKLEVBSXNCO0FBQUEsU0FIbkNPLGtCQUdtQyxHQUhmLElBR2U7QUFBQSxTQUZuQ0MsWUFFbUMsR0FGbkIsNEJBRW1COztBQUNqQyxRQUFJSCxhQUFKLEVBQXFCO0FBQ25CO0FBQ0EsV0FBS0MsVUFBTCxDQUFnQkcsR0FBaEIsQ0FBb0JDLEtBQUtDLE1BQUwsQ0FBWUMs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O0FBWUQ7O0FBRUQ7QUFDQW5ELG1CQUFpQjtBQUNmdkIsU0FBS1ksUUFBTCxDQUFjaUUseUJBQWQsQ0FBd0MsS0FBSy9FLFlBQTdDO0FBQ0Q7O0FBRUQ7QUFDQTBCLDJCQUF5QjtBQUN2QixXQUFPLEtBQUt1QyxrQkFBTCxHQUEwQjFDLElBQTFCLENBQWdDeUQsZUFBRCxJQUFxQjtBQUN6RCxXQUFLLElBQUlDLGtCQUFULElBQStCRCxlQUEvQixFQUFnRDtBQUM5QyxZQUFJRSx5QkFBeUIsS0FBSzVCLCtCQUFMLENBQXFDMkIsa0JBQXJDLENBQTdCO0FBQ0EzRixXQUFHNkYsTUFBSCxDQUFVRCxzQkFBVjtBQUNEO0FBQ0YsS0FMTSxDQUFQO0FBT0Q7QUF4T29CLENBRHZCIiwiZmlsZSI6ImNyZWF0ZS10dGwtZ3JhbW1hci5qcyIsInNvdXJjZXNDb250ZW50IjpbIi8qZ2xvYmFsIGF0b20qL1xyXG5jb25zdCBjcnlwdG8gPSByZXF1aXJlKCdjcnlwdG8nKTtcclxuY29uc3QgZnMgPSByZXF1aXJlKCdmcycpO1xyXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xyXG5jb25zdCBDb21wb3NpdGVEaXNwb3NhYmxlID0gcmVxdWlyZSgnYXRvbScpLkNvbXBvc2l0ZURpc3Bvc2FibGU7XHJcblxyXG4vLyBUaGlzIENsYXNzIGlzIHJlcHNvbnNpYmxlIGZvciBjcmVhdGluZyBhIG5ldyBUYWdnZWQgVGVtcGxhdGUgZ3JhbW1hclxyXG4vLyBvbiBkZXRlY3Rpb24gb2YgYSBjaGFuZ2VkIFRhZ2dlZCBUZW1wbGF0ZSBDb25maWd1cmF0aW9uIGluIHRoZSBwYWNrYWdlIHNldHRpbmdzXHJcbm1vZHVsZS5leHBvcnRzID1cclxuY2xhc3MgQ3JlYXRlVHRsR3JhbW1hciB7XHJcblxyXG4gIGRpc3Bvc2FibGUgPSBuZXcgQ29tcG9zaXRlRGlzcG9zYWJsZSgpO1xyXG4gIGNvbmZpZ0NoYW5nZWRUaW1lcj0gbnVsbDtcclxuICBUVExTQ09QRU5BTUUgPSBgbGFuZ3VhZ2ViYWJlbC50dGxleHRlbnNpb25gXHJcblxyXG4gIGNvbnN0cnVjdG9yKG9ic2VydmVDb25maWcgPSBmYWxzZSkge1xyXG4gICAgaWYgKG9ic2VydmVDb25maWcpICAge1xyXG4gICAgICAvLyBsb29rIGZvciBjaGFuZ2VzIGluIHRhZ2dlZCB0ZW1wbGF0ZSBoYW5kbGVyc1xyXG4gICAgICB0aGlzLmRpc3Bvc2FibGUuYWRkKGF0b20uY29uZmlnLm9ic2VydmUoJ2xhbmd1YWdlLWJhYmVsLnRhZ2dlZFRlbXBsYXRlR3JhbW1hcicsIHRoaXMub2JzZXJ2ZVR0bENvbmZpZy5iaW5kKHRoaXMsIDEwMDAwKSkpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGVzdHJveSgpIHtcclxuICAgIHRoaXMuZGlzcG9zYWJsZS5kaXNwb3NlKCk7XHJcbiAgfVxyXG5cclxuICAvLyBhZGQgbmV3IGdyYW1tYXJzIHRvIHJlZ2lzdHJ5XHJcbiAgYWRkR3JhbW1hcnMoZmlsZW5hbWUpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGF0b20uZ3JhbW1hcnMubG9hZEdyYW1tYXIoZmlsZW5hbWUsIChlcnIpID0+IHtcclxuICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICByZWplY3QobmV3IEVycm9yKGBVbmFibGUgdG8gYWRkIEdyYW1tYXIgdG8gcmVnaXN0cnlcXG4ke2ZpbGVuYW1lfWApKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSByZXNvbHZlKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gIH1cclxuXHJcbiAgLy8gQ2hlY2sgaWYgdGhlIGdyYW1tYXIgZXhpc3RzIHVuZGVyIHRoaXMgU0hBMjU2IGZpbGUgbmFtZVxyXG4gIC8vIElmIG5vdCB0aGVuIHJlbW92ZSBhbGwgdHRsIGdyYW1tYXJzIGFuZCBjcmVhdGUgYSBuZXcgb25lXHJcbiAgLy8gVGhpcyByZXR1cm5zIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzICB3aXRoIGEgdHRsIGZpbGVuYW1lXHJcbiAgLy8gaWYgYSBuZXcgZ3JhbW1hciB3YXMgY3JlYXRlZCBvciByZWplY3RzIGlmIGEgcHJvYmxlbS5cclxuICBjcmVhdGVHcmFtbWFyKHt0dGxGaWxlbmFtZSwgdHRsRmlsZW5hbWVBYnNvbHV0ZSwgZ3JhbW1hclRleHR9KSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICB0aGlzLmRvZXNHcmFtbWFyRmlsZUV4aXN0KHR0bEZpbGVuYW1lKVxyXG4gICAgICAgIC50aGVuKChpZkZpbGVFeGlzdHMpID0+IHtcclxuICAgICAgICAgIGlmIChpZkZpbGVFeGlzdHMpIHtcclxuICAgICAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMucmVtb3ZlR3JhbW1hcnMoKTtcclxuICAgICAgICAgICAgdGhpcy5yZW1vdmVUdGxMYW5ndWFnZUZpbGVzKClcclxuICAgICAgICAgICAgLnRoZW4oKCkgPT4gdGhpcy5jcmVhdGVHcmFtbWFyRmlsZSh0dGxGaWxlbmFtZUFic29sdXRlLCBncmFtbWFyVGV4dCkpXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHRoaXMuYWRkR3JhbW1hcnModHRsRmlsZW5hbWVBYnNvbHV0ZSkpXHJcbiAgICAgICAgICAgIC50aGVuKCgpID0+IHtcclxuICAgICAgICAgICAgICBhdG9tLm5vdGlmaWNhdGlvbnMuYWRkSW5mbygnbGFuZ3VhZ2UtYmFiZWwnLCB7ZGV0YWlsOiBgR3JhbW1hciBjcmVhdGVkIGF0IFxcbiR7dHRsRmlsZW5hbWVBYnNvbHV0ZX1gLGRpc21pc3NhYmxlOiB0cnVlfSk7XHJcbiAgICAgICAgICAgICAgcmVzb2x2ZSh0dGxGaWxlbmFtZSk7XHJcbiAgICAgICAgICAgIH0pXHJcbiAgICAgICAgICAgIC5jYXRjaCgoZXJyKSA9PiB7XHJcbiAgICAgICAgICAgICAgYXRvbS5ub3RpZmljYXRpb25zLmFkZFdhcm5pbmcoJ2xhbmd1YWdlLWJhYmVsJywge2RldGFpbDogYCR7ZXJyLm1lc3NhZ2V9YCxkaXNtaXNzYWJsZTogdHJ1ZX0pO1xyXG4gICAgICAgICAgICAgIHJlamVjdChlcnIpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLy8gd3JpdGUgdGhlIHR0bCBncmFtbWFyIGZpbGUgZm9yIHRoaXMgY29uZmlnXHJcbiAgY3JlYXRlR3JhbW1hckZpbGUoZmlsZW5hbWUsdGV4dCkge1xyXG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgZnMud3JpdGVGaWxlKGZpbGVuYW1lLCB0ZXh0LCAoZXJyKSA9PiB7XHJcbiAgICAgICAgaWYgKGVycikgcmVqZWN0KG5ldyBFcnJvcihlcnIpKTtcclxuICAgICAgICBlbHNlIHJlc29sdmUoKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIGNyZWF0ZSBhIEdyYW1tYXIgZmlsZSdzIEpTT04gdGV4dFxyXG4gIGNyZWF0ZUdyYW1tYXJUZXh0KCkge1xyXG4gICAgcmV0dXJuIGB7XHJcbiAgXCJjb21tZW50XCI6IFwiQXV0byBnZW5lcmF0ZWQgVGFnIEV4dGVuc2lvbnMgZm9yIGxhbmd1YWdlLWJhYmVsXCIsXHJcbiAgXCJjb21tZW50XCI6IFwiUGxlYXNlIGRvIG5vdCBlZGl0IHRoaXMgZmlsZSBkaXJlY3RseVwiLFxyXG4gIFwic2NvcGVOYW1lXCI6IFwiJHt0aGlzLlRUTFNDT1BFTkFNRX1cIixcclxuICBcImZpbGVUeXBlc1wiOiBbXSxcclxuICBcInBhdHRlcm5zXCI6IFtcclxuICAgICR7dGhpcy5nZXRUdGxDb25maWcoKS5tYXAoKHR0bFN0cmluZykgPT4gKHRoaXMuY3JlYXRlR3JhbW1hclBhdHRlcm5zKHR0bFN0cmluZykpKX1cclxuICBdXHJcbn1gO1xyXG4gIH1cclxuXHJcbiAgLy8gQ3JlYXRlIGEgZ3JhbW1hcidzIHBhdHRlcm4gZGVyaXZlZCBmcm9tIGEgdGhlIHRhZ2dlZCB0ZW1wbGF0ZSBzdHJpbmdcclxuICAvLyBpbiB0aGUgZm9ybSBtYXRjaFN0cmluZzppbmNsdWRlU2NvcGVcclxuICBjcmVhdGVHcmFtbWFyUGF0dGVybnModHRsU3RyaW5nKSB7XHJcbiAgICBsZXQgbGFzdENvbG9uSW5kZXggPSB0dGxTdHJpbmcubGFzdEluZGV4T2YoJzonKTtcclxuICAgIGxldCBtYXRjaFN0cmluZyA9IHR0bFN0cmluZy5zdWJzdHJpbmcoMCwgbGFzdENvbG9uSW5kZXgpO1xyXG4gICAgbGV0IGluY2x1ZGVTY29wZSA9IHR0bFN0cmluZy5zdWJzdHJpbmcobGFzdENvbG9uSW5kZXgrMSk7XHJcbiAgICBjb25zdCBpc1ZhbGlkSW5jbHVkZVNjb3BlID0gL14oW2EtekEtWl1cXHcqXFwuPykqKFxcdyMoW2EtekEtWl1cXHcqXFwuPykqKT9cXHckLztcclxuXHJcbiAgICBpZiAobWF0Y2hTdHJpbmcubGVuZ3RoIDwgMSB8fCAhaXNWYWxpZEluY2x1ZGVTY29wZS50ZXN0KGluY2x1ZGVTY29wZSkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBpbiB0aGUgVGFnZ2VkIFRlbXBsYXRlIEdyYW1tYXIgU3RyaW5nICR7dHRsU3RyaW5nfWApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICggL15cXFwiLipcXFwiJC8udGVzdChtYXRjaFN0cmluZykpIHtcclxuICAgICAgLy8gRm91bmQgYSBwb3NzaWJsZSByZWdleHAgaW4gdGhlIGZvcm0gXCJyZWdleFwiIHNvIHN0cmlwIHRoZSBcIlxyXG4gICAgICAvLyBUaGlzIGlzIGEgb25pZ3VydW1hIHJlZ2V4IGJ1dCB3ZSB3aWxsIGRvIGEgc2ltcGxlIEpTIHJlZ2V4IHRlc3QgZm9yXHJcbiAgICAgIC8vIHZhbGlkaXR5IGFzIGl0IGlzIG1vc3QgbGlrZWx5IGNsb3NlIGVub3VnaCFcclxuICAgICAgbWF0Y2hTdHJpbmcgPSBtYXRjaFN0cmluZy5zdWJzdHJpbmcoMSwgbWF0Y2hTdHJpbmcubGVuZ3RoIC0xKTtcclxuICAgICAgdHJ5IHtcclxuICAgICAgICAvLyB0aGUgcmVnZXggc2hvdWxkbid0IGhhdmUgYSBzaW5nbGUgc2xhc2ggZXhjZXB0IGJlZm9yZSBhIFwiXHJcbiAgICAgICAgaWYgKCAvXFxcXFteXCJdL2cudGVzdChtYXRjaFN0cmluZy5yZXBsYWNlKC9cXFxcXFxcXC9nLFwiXCIpKSkge1xyXG4gICAgICAgICAgdGhyb3cgdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gY29udmVydCBcXGFueWNoYXIgdG8gYW55Y2hhcjtcclxuICAgICAgICBuZXcgUmVnRXhwKG1hdGNoU3RyaW5nLnJlcGxhY2UoL1xcXFwoW15cXFxcXSkvZyxcIiQxXCIpKTtcclxuICAgICAgfVxyXG4gICAgICBjYXRjaCAoZXJyKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZb3UgZW50ZXJlZCBhbiBiYWRseSBmb3JtZWQgUmVnRXhwIGluIHRoZSBUYWdnZWQgVGVtcGxhdGUgR3JhbW1hciBzZXR0aW5ncy5cXG4ke21hdGNoU3RyaW5nfWApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICggL1wiL2cudGVzdChtYXRjaFN0cmluZykpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBCYWQgbGl0ZXJhbCBzdHJpbmcgaW4gdGhlIFRhZ2dlZCBUZW1wbGF0ZSBHcmFtbWFyIHNldHRpbmdzLlxcbiR7bWF0Y2hTdHJpbmd9YCk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgY29uc3QgZXNjYXBlU3RyaW5nUmVnRXhwID0gL1t8XFxcXHt9KClbXFxdXiQrKj8uXS9nO1xyXG4gICAgICAvLyBHZXQgYSB2YWxpZCByZWdleHAgZXNjYXBlZCBzdHJpbmcuIGUuZy4gJy8qKiBAaHRtbCAqLycgLT4gJ1xcL1xcKlxcKiBAaHRtbCBcXCpcXC8nXHJcbiAgICAgIG1hdGNoU3RyaW5nID0gbWF0Y2hTdHJpbmcucmVwbGFjZShlc2NhcGVTdHJpbmdSZWdFeHAsICdcXFxcXFxcXCQmJyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGB7XHJcbiAgICAgIFwiY29udGVudE5hbWVcIjogXCJtZXRhLnR0bC1ncmFtbWFyLmpzXCIsXHJcbiAgICAgIFwiYmVnaW5cIjogXCJcXFxcXFxcXHMqKygke21hdGNoU3RyaW5nfSlcXFxcXFxcXHMqKFxcYClcIixcclxuICAgICAgXCJiZWdpbkNhcHR1cmVzXCI6IHtcclxuICAgICAgICBcIjFcIjogeyBcIm5hbWVcIjogXCJlbnRpdHkubmFtZS50YWcuanNcIiB9LFxyXG4gICAgICAgIFwiNFwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLmRlZmluaXRpb24ucXVhc2kuYmVnaW4uanNcIiB9XHJcbiAgICAgIH0sXHJcbiAgICAgIFwiZW5kXCI6IFwiXFxcXFxcXFxzKig/PCFcXFxcXFxcXFxcXFxcXFxcKShcXGApXCIsXHJcbiAgICAgIFwiZW5kQ2FwdHVyZXNcIjoge1xyXG4gICAgICAgIFwiMVwiOiB7IFwibmFtZVwiOiBcInB1bmN0dWF0aW9uLmRlZmluaXRpb24ucXVhc2kuZW5kLmpzXCIgfVxyXG4gICAgICB9LFxyXG4gICAgICBcInBhdHRlcm5zXCI6IFtcclxuICAgICAgICB7IFwiaW5jbHVkZVwiOiBcInNvdXJjZS5qcy5qc3gjbGl0ZXJhbC1xdWFzaS1lbWJlZGRlZFwiIH0sXHJcbiAgICAgICAgeyBcImluY2x1ZGVcIjogXCIke2luY2x1ZGVTY29wZX1cIiB9XHJcbiAgICAgIF1cclxuICAgIH1gO1xyXG4gIH1cclxuXHJcbiAgLy8gY2hlY2tzIGEgdHRsIGdyYW1tYXIgZmlsZW5hbWUgZXhpc3RzXHJcbiAgLy8gcmV0dXJucyBhIFByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0cnVlIGlmIHR0bEZpbGVOYW1lIGV4aXN0c1xyXG4gIGRvZXNHcmFtbWFyRmlsZUV4aXN0KHR0bEZpbGVuYW1lKSB7XHJcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcclxuICAgICAgZnMuYWNjZXNzKHRoaXMubWFrZVR0bEdyYW1tYXJGaWxlbmFtZUFic291bHV0ZSh0dGxGaWxlbmFtZSksIGZzLkZfT0ssIChlcnIpID0+IHtcclxuICAgICAgICBlcnIgPyByZXNvbHZlKGZhbHNlKTogcmVzb2x2ZSh0cnVlKTtcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIGdldCBmdWxsIHBhdGggdG8gdGhlIGxhbmd1YWdlLWJhYmVsIGdyYW1tYXIgZmlsZSBkaXJcclxuICBnZXRHcmFtbWFyUGF0aCgpIHtcclxuICAgIHJldHVybiBwYXRoLm5vcm1hbGl6ZShcclxuICAgICAgcGF0aC5yZXNvbHZlKGF0b20ucGFja2FnZXMubG9hZGVkUGFja2FnZXNbJ2xhbmd1YWdlLWJhYmVsJ10ucGF0aCwgJy4vZ3JhbW1hcnMnKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8vIGdldCBhbiBhcnJheSBvZiBhbGwgbGFuZ3VhZ2UtYmFiZWwgZ3JhbW1hciBmaWxlc1xyXG4gIGdldEdyYW1tYXJGaWxlcygpIHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSxyZWplY3QpID0+IHtcclxuICAgICAgZnMucmVhZGRpcih0aGlzLmdldEdyYW1tYXJQYXRoKCksKGVyciwgZGF0YSkgPT4ge1xyXG4gICAgICAgIGlmIChlcnIpIHJlamVjdChuZXcgRXJyb3IoZXJyKSk7XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICByZXNvbHZlKGRhdGEpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8vIHJlYWQgY29uZmlndXJhdGlvbnMgZm9yIHRhZ2dlZCB0ZW1wbGF0ZXNcclxuICBnZXRUdGxDb25maWcoKSB7XHJcbiAgICByZXR1cm4gYXRvbS5jb25maWcuZ2V0KCdsYW5ndWFnZS1iYWJlbCcpLnRhZ2dlZFRlbXBsYXRlR3JhbW1hcjtcclxuICB9XHJcblxyXG4gIC8vIGdldCBhbiBhcnJheSBvZiBncmFtbWFyIHRhZ2dlZCB0ZW1wbGF0ZSBleHRlbnNpb24gZmlsZW5hbWVzXHJcbiAgZ2V0VHRsR3JhbW1hckZpbGVzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuZ2V0R3JhbW1hckZpbGVzKCkudGhlbihkaXJGaWxlcyA9PiBkaXJGaWxlcy5maWx0ZXIoZnVuY3Rpb24oZmlsZW5hbWUpIHtcclxuICAgICAgcmV0dXJuIC9edHRsLS8udGVzdChmaWxlbmFtZSk7XHJcbiAgICB9KSk7XHJcbiAgfVxyXG5cclxuICAvLyBnZW5lcmF0ZSBhIFNIQTI1NiBmb3Igc29tZSB0ZXh0XHJcbiAgZ2VuZXJhdGVUdGxTSEEyNTYoc3RyaW5nVG9IYXNoKSB7XHJcbiAgICBsZXQgaGFzaCA9IGNyeXB0by5jcmVhdGVIYXNoKCdzaGEyNTYnKTtcclxuICAgIGhhc2gudXBkYXRlKHN0cmluZ1RvSGFzaCk7XHJcbiAgICByZXR1cm4gaGFzaC5kaWdlc3QoJ2hleCcpO1xyXG4gIH1cclxuXHJcbiAgLy8gdGFnZ2VkIHRlbXBsYXRlIGZpbGVuYW1lXHJcbiAgbWFrZVR0bEdyYW1tYXJGaWxlbmFtZShoYXNoU3RyaW5nKSB7XHJcbiAgICByZXR1cm4gYHR0bC0ke2hhc2hTdHJpbmd9Lmpzb25gO1xyXG4gIH1cclxuXHJcbiAgLy8gZ2V0IGEgZnVsbHkgcXVhbGlmaWVkIGZpbGVuYW1lXHJcbiAgbWFrZVR0bEdyYW1tYXJGaWxlbmFtZUFic291bHV0ZSh0dGxGaWxlbmFtZSkge1xyXG4gICAgcmV0dXJuIHBhdGgucmVzb2x2ZSh0aGlzLmdldEdyYW1tYXJQYXRoKCksIHR0bEZpbGVuYW1lKTtcclxuICB9XHJcblxyXG5cclxuICAvLyBvYnNlcnZlIGNoYW5nZXMgaW4gdGhlIHRhZ2dlZFRlbXBsYXRlR3JhbW1hciBjb25maWcgd2hpY2ggdGFrZSBwbGFjZVxyXG4gIC8vIGJlY2F1c2Ugb2JzZXJ2ZWQgY29uZmlnIGNoYW5nZXMgYXJlIGZpcmVkIGFzIGEgdXNlciB0eXBlcyB0aGVtIGluc2lkZVxyXG4gIC8vIHNldHRpbmdzIHdlIG5lZWQgdG8gZGVsYXkgcHJvY2Vzc2luZyB0aGUgYXJyYXkgc3RyaW5ncywgdW50aWwgbGFzdCBjaGFyXHJcbiAgLy8gZW50ZXJlZCB3YXMgc2V0VGltZW91dCBzZWNvbmRzIGFnby4gcGFyc2UgdGFnZ2VkIHRlbXBsYXRlIGNvbmZpZ3VyYXRpb25cclxuICAvLyBhbmQgdGhlbiBjcmVhdGUgZ3JhbW1hciBhbmQgZ2VuZXJhdGUgYSBTSEEyNTYgaGFzaCBmcm9tIHRoZSBncmFtbWFyXHJcbiAgb2JzZXJ2ZVR0bENvbmZpZyh0aW1lb3V0KSB7XHJcbiAgICBpZiAodGhpcy5jb25maWdDaGFuZ2VkVGltZXIpIGNsZWFyVGltZW91dCh0aGlzLmNvbmZpZ0NoYW5nZWRUaW1lcik7XHJcbiAgICB0aGlzLmNvbmZpZ0NoYW5nZWRUaW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIGNvbnN0IGdyYW1tYXJUZXh0ID0gdGhpcy5jcmVhdGVHcmFtbWFyVGV4dCgpO1xyXG4gICAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLmdlbmVyYXRlVHRsU0hBMjU2KGdyYW1tYXJUZXh0KTtcclxuICAgICAgICBjb25zdCB0dGxGaWxlbmFtZSA9IHRoaXMubWFrZVR0bEdyYW1tYXJGaWxlbmFtZShoYXNoKTtcclxuICAgICAgICBjb25zdCB0dGxGaWxlbmFtZUFic29sdXRlID0gdGhpcy5tYWtlVHRsR3JhbW1hckZpbGVuYW1lQWJzb3VsdXRlKHR0bEZpbGVuYW1lKTtcclxuICAgICAgICB0aGlzLmNyZWF0ZUdyYW1tYXIoe3R0bEZpbGVuYW1lLCB0dGxGaWxlbmFtZUFic29sdXRlLCBncmFtbWFyVGV4dH0pO1xyXG4gICAgICB9XHJcbiAgICAgIGNhdGNoKGVycikge1xyXG4gICAgICAgIGF0b20ubm90aWZpY2F0aW9ucy5hZGRXYXJuaW5nKCdsYW5ndWFnZS1iYWJlbCcsIHtkZXRhaWw6IGAke2Vyci5tZXNzYWdlfWAsZGlzbWlzc2FibGU6IHRydWV9KTtcclxuICAgICAgfVxyXG4gICAgfSwgdGltZW91dCk7XHJcbiAgfVxyXG5cclxuICAvLyBSZW1vdmUgZ3JhbW1hcnMgYmVmb3JlIHVwb2RhdGluZ1xyXG4gIHJlbW92ZUdyYW1tYXJzKCkge1xyXG4gICAgYXRvbS5ncmFtbWFycy5yZW1vdmVHcmFtbWFyRm9yU2NvcGVOYW1lKHRoaXMuVFRMU0NPUEVOQU1FKTtcclxuICB9XHJcblxyXG4gIC8vIHJlbW92ZSBhbGwgbGFuZ3VhZ2UgZmlsZXMgaW4gdGFnZ2VkIHRlbXBsYXRlIEdyYW1tYXJGaWxlcyBhcnJheVxyXG4gIHJlbW92ZVR0bExhbmd1YWdlRmlsZXMoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5nZXRUdGxHcmFtbWFyRmlsZXMoKS50aGVuKCh0dGxHcmFtbWFyRmlsZXMpID0+IHtcclxuICAgICAgZm9yIChsZXQgdHRsR3JhbW1hckZpbGVuYW1lIG9mIHR0bEdyYW1tYXJGaWxlcykge1xyXG4gICAgICAgIGxldCB0dGxHcmFtbWFyRmlsZUFic291bHRlID0gdGhpcy5tYWtlVHRsR3JhbW1hckZpbGVuYW1lQWJzb3VsdXRlKHR0bEdyYW1tYXJGaWxlbmFtZSk7XHJcbiAgICAgICAgZnMudW5saW5rKHR0bEdyYW1tYXJGaWxlQWJzb3VsdGUpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgfVxyXG59O1xyXG4iXX0=