'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.enablePackage = undefined;

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var enablePackage = exports.enablePackage = function () {
  var _ref = _asyncToGenerator(function* (packageName) {
    if (atom.packages.isPackageDisabled(packageName)) {
      atom.packages.enablePackage(packageName);
    }
    if (!atom.packages.isPackageLoaded(packageName)) {
      atom.packages.loadPackage(packageName);
    }
    if (!atom.packages.isPackageActive(packageName)) {
      yield atom.packages.activatePackage(packageName);
    }
  });

  return function enablePackage(_x) {
    return _ref.apply(this, arguments);
  };
}();

exports.apmInstall = apmInstall;
exports.getDependencies = getDependencies;

var _sbExec = require('sb-exec');

function _asyncToGenerator(fn) { return function () { var gen = fn.apply(this, arguments); return new Promise(function (resolve, reject) { function step(key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { return Promise.resolve(value).then(function (value) { return step("next", value); }, function (err) { return step("throw", err); }); } } return step("next"); }); }; }

var VALID_TICKS = new Set(['âœ“', 'done']);
var VALIDATION_REGEXP = /(?:Installing|Moving) (.*?) to .* (.*)/;

function apmInstall(dependencies, progressCallback) {
  var errors = new Map();
  return Promise.all(dependencies.map(function (dependency) {
    return (0, _sbExec.exec)(atom.packages.getApmPath(), ['install', dependency.url, '--production', '--color', 'false'], {
      stream: 'both',
      ignoreExitCode: true
    }).then(function (output) {
      var successful = VALIDATION_REGEXP.test(output.stdout) && VALID_TICKS.has(VALIDATION_REGEXP.exec(output.stdout)[2]);
      progressCallback(dependency.name, successful);
      if (!successful) {
        var error = new Error('Error installing dependency: ' + dependency.name);
        error.stack = output.stderr;
        throw error;
      }
    }).catch(function (error) {
      errors.set(dependency.name, error);
    });
  })).then(function () {
    return errors;
  });
}

function getDependencies(packageName) {
  var toReturn = [];
  var packageModule = atom.packages.getLoadedPackage(packageName);
  var packageDependencies = packageModule && packageModule.metadata['package-deps'];

  if (packageDependencies) {
    var _arr = packageDependencies;

    for (var _i = 0; _i < _arr.length; _i++) {
      var entry = _arr[_i];
      var entryName = entry;
      var entryUrl = entry;

      if (entry.indexOf('#') > -1) {
        var _entry$split = entry.split('#');

        var _entry$split2 = _slicedToArray(_entry$split, 2);

        entryName = _entry$split2[0];
        entryUrl = _entry$split2[1];
      }

      if (__steelbrain_package_deps.has(entryName) || atom.packages.resolvePackagePath(entryName)) {
        continue;
      }
      __steelbrain_package_deps.add(entryName);
      toReturn.push({
        url: entryUrl,
        name: entryName
      });
    }
  } else {
    console.error('[Package-Deps] Unable to get loaded package \'' + packageName + '\'');
  }

  return toReturn;
}