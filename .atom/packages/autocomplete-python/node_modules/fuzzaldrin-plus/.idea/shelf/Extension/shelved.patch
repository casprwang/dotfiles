Index: spec/filter-spec.coffee
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- spec/filter-spec.coffee	(revision 9d5c94a0b83aeee8f5407378f453b43be7741e5e)
+++ spec/filter-spec.coffee	(revision )
@@ -31,10 +31,10 @@
 
   it "support unicode character with different length uppercase", ->
 
-    candidates = ["Bernauer Stra\u00DFe Wall"] # Bernauer Stra�e Wall
+    candidates = ["Bernauer Stra\u00DFe Wall"] # Bernauer Straße Wall
     expect(filter(candidates, 'Stra\u00DFe Wall')).toEqual candidates
-  # before correction, The map �->SS , place the W out of sync and prevent a match.
-  # After correction we map �->S.
+  # before correction, The map ß->SS , place the W out of sync and prevent a match.
+  # After correction we map ß->S.
 
   describe "when the maxResults option is set", ->
     it "limits the results to the result size", ->
@@ -528,6 +528,25 @@
 
       expect(bestMatch(candidates, 'core')).toBe candidates[1]
       expect(bestMatch(candidates, 'foo')).toBe candidates[0]
+
+    it "prefers file of the specified extension", ->
+
+      candidates = [
+        path.join('meas_astrom', 'include', 'Isst', 'meas','astrom','matchOptimisticB.h')
+        path.join('IsstDoxygen', 'html', 'match_optimistic_b_8cc.html')
+      ]
+
+      expect(bestMatch(candidates, 'mob.h')).toBe candidates[0]
+
+      candidates = [
+        path.join('matchOptimisticB.htaccess')
+        path.join('matchOptimisticB_main.html')
+      ]
+
+      expect(bestMatch(candidates, 'mob.ht')).toBe candidates[1]
+
+
+
 
     it "ignores trailing slashes", ->
 
Index: src/scorer.coffee
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- src/scorer.coffee	(revision 9d5c94a0b83aeee8f5407378f453b43be7741e5e)
+++ src/scorer.coffee	(revision )
@@ -65,6 +65,7 @@
     @core_lw = @core.toLowerCase()
     @core_up = truncatedUpperCase(@core)
     @depth = countDir(query, query.length)
+    @ext = getExtension(@query_lw)
 
 
 exports.prepQuery = (query) ->
@@ -451,9 +452,11 @@
   # Get position of basePath of subject.
   basePos = subject.lastIndexOf(PathSeparator, end)
 
-  #If no PathSeparator, no base path exist.
-  return fullPathScore if (basePos is -1)
+  # Get a bonus for matching extension
+  extAdjust = 1.0 + getExtensionScore(subject_lw, prepQuery.ext)
+  fullPathScore *= extAdjust
 
+
   # Get the number of folder in query
   depth = prepQuery.depth
 
@@ -466,6 +469,7 @@
   basePos++
   end++
   basePathScore = doScore(subject[basePos...end], subject_lw[basePos...end], prepQuery)
+  basePathScore *= extAdjust
 
   # Final score is linear interpolation between base score and full path score.
   # For low directory depth, interpolation favor base Path then include more of full path as depth increase
@@ -500,6 +504,32 @@
 
   return count
 
+
+getExtension = (str) ->
+  pos = str.lastIndexOf(".")
+  if pos < 0 then ""  else  str.substr(pos + 1)
+
+
+getExtensionScore = (candidate, ext) ->
+  return 0 unless ext.length
+  pos = candidate.lastIndexOf(".") + 1
+  return 0 unless pos > 1
+
+  n = ext.length
+  m = candidate.length - pos
+
+  #n contain the smallest of both extension length, m the largest.
+  if( m < n)
+    n = m
+    m = ext.length
+
+  #count number of matching characters in extension
+  matched = -1
+  while ++matched < n then break unless candidate[pos + matched] is ext[matched]
+
+  #cannot divide by zero because m is the largest and we return if either is 0
+  return  matched / m
+
 #
 # Truncated Upper Case:
 # --------------------
@@ -511,11 +541,11 @@
 # See ftp://ftp.unicode.org/Public/UCD/latest/ucd/SpecialCasing.txt for the list
 #
 # One common example is 'LATIN SMALL LETTER SHARP S' (U+00DF)
-# "Stra�e".toUpperCase() === "STRASSE" // length goes from 6 char to 7 char
+# "Straße".toUpperCase() === "STRASSE" // length goes from 6 char to 7 char
 #
 # Fortunately only uppercase is touched by the exceptions.
 #
-# truncatedUpperCase("Stra�e") returns "STRASE"
+# truncatedUpperCase("Straße") returns "STRASE"
 # iterating over every character, getting uppercase variant and getting first char of that.
 #
 # This works for isMatch because we require candidate to contain at least this string.
\ No newline at end of file
