{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":"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","sourcesContent":["\"use strict\";\n\nimport * as ts from \"typescript\";\nimport formatter from \"./formatter\";\nimport {createDefaultFormatCodeOptions} from \"./utils\";\n\nimport * as fs from \"fs\";\n\nimport base from \"./provider/base\";\nimport tsconfigjson from \"./provider/tsconfigjson\";\nimport editorconfig from \"./provider/editorconfig\";\nimport tslintjson, {postProcess as tslintPostProcess} from \"./provider/tslintjson\";\n\nexport interface Options {\n    dryRun?: boolean;\n    verbose?: boolean;\n    baseDir?: string;\n    replace: boolean;\n    verify: boolean;\n    tsconfig: boolean;\n    tslint: boolean;\n    editorconfig: boolean;\n    tsfmt: boolean;\n}\n\nexport interface PostProcess {\n    (fileName: string, formattedCode: string, opts: Options, formatOptions: ts.FormatCodeOptions): string;\n}\n\nexport interface ResultMap {\n    [fileName: string]: Result;\n}\n\nexport interface Result {\n    fileName: string;\n    options: ts.FormatCodeOptions;\n    message: string;\n    error: boolean;\n    src: string;\n    dest: string;\n}\n\nexport function processFiles(files: string[], opts: Options): Promise<ResultMap> {\n    \"use strict\";\n\n    let resultMap: ResultMap = {};\n    let promises = files.map(fileName => {\n        if (!fs.existsSync(fileName)) {\n            let result: Result = {\n                fileName: fileName,\n                options: null,\n                message: `${fileName} does not exist. process abort.\\n`,\n                error: true,\n                src: \"\",\n                dest: \"\",\n            };\n            return Promise.resolve(result);\n        }\n\n        let content = fs.readFileSync(fileName).toString();\n        return processString(fileName, content, opts);\n    });\n    return Promise.all<Result>(promises).then(resultList => {\n        resultList.forEach(result => {\n            resultMap[result.fileName] = result;\n        });\n        return resultMap;\n    });\n}\n\nexport function processStream(fileName: string, input: NodeJS.ReadableStream, opts: Options): Promise<Result> {\n    \"use strict\";\n\n    input.setEncoding(\"utf8\");\n\n    let promise = new Promise<string>((resolve, reject) => {\n        let fragment = \"\";\n        input.on(\"data\", (chunk: string) => {\n            fragment += chunk;\n        });\n\n        input.on(\"end\", () => {\n            resolve(fragment);\n        });\n    });\n    return promise.then(content => processString(fileName, content, opts));\n}\n\nexport function processString(fileName: string, content: string, opts: Options): Promise<Result> {\n    \"use strict\";\n\n    let formatOptions = createDefaultFormatCodeOptions();\n    let optGenPromises: (ts.FormatCodeOptions | Promise<ts.FormatCodeOptions>)[] = [];\n    let postProcesses: PostProcess[] = [];\n    if (opts.tsfmt) {\n        optGenPromises.push(base(fileName, opts, formatOptions));\n    }\n    if (opts.tsconfig) {\n        optGenPromises.push(tsconfigjson(fileName, opts, formatOptions));\n    }\n    if (opts.editorconfig) {\n        optGenPromises.push(editorconfig(fileName, opts, formatOptions));\n    }\n    if (opts.tslint) {\n        optGenPromises.push(tslintjson(fileName, opts, formatOptions));\n        postProcesses.push(tslintPostProcess);\n    }\n\n    return Promise\n        .all(optGenPromises)\n        .then(() => {\n            let formattedCode = formatter(fileName, content, formatOptions);\n            if ((<any>formattedCode).trimRight) {\n                formattedCode = (<any>formattedCode).trimRight();\n                formattedCode += formatOptions.NewLineCharacter;\n            }\n\n            postProcesses.forEach(postProcess => {\n                formattedCode = postProcess(fileName, formattedCode, opts, formatOptions) || formattedCode;\n            });\n\n            // replace newline code. maybe NewLineCharacter params affect to only \"new\" newline by language service.\n            formattedCode = formattedCode.replace(/\\r?\\n/g, formatOptions.NewLineCharacter);\n\n            let message: string;\n            let error = false;\n            if (opts && opts.verify) {\n                if (content !== formattedCode) {\n                    message = `${fileName} is not formatted\\n`;\n                    error = true;\n                }\n            } else if (opts && opts.replace) {\n                if (content !== formattedCode) {\n                    fs.writeFileSync(fileName, formattedCode);\n                    message = `replaced ${fileName}\\n`;\n                }\n            } else if (opts && !opts.dryRun) {\n                message = formattedCode;\n            }\n\n            let result: Result = {\n                fileName: fileName,\n                options: formatOptions,\n                message: message,\n                error: error,\n                src: content,\n                dest: formattedCode,\n            };\n            return Promise.resolve(result);\n        });\n}\n"]}