/**
* glob-expand https://github.com/anodynos/node-glob-expand
*
* A sync glob / minimatch / RegExp function with a gruntjs -like `expand` of patterns, with minimum depepndencies. Derived from gruntjs's v0.4.1 `file.expand`
* Version 0.2.1 - Compiled on 2016-09-02 01:32:18
* Repository git://github.com/anodynos/node-glob-expand
* Copyright(c) 2016 Angelos Pikoulas <agelos.pikoulas@gmail.com>
* License MIT http://www.opensource.org/licenses/mit-license.php
*/

// Generated by uRequire v0.7.0-beta.29 target: 'build' template: 'nodejs'


var VERSION = '0.2.1'; // injected by urequire-rc-inject-version

var expand, fs, glob, path, processPatterns, _, __slice = [].slice;
_ = require("lodash");
glob = require("glob");
fs = require("fs");
path = require("path");
expand = function () {
  var args, matches, options, patterns;
  args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
  options = _.isPlainObject(args[0]) ? args.shift() : {};
  patterns = _.isArray(args[0]) ? args[0] : args;
  if (patterns.length === 0) {
    return [];
  }
  matches = processPatterns(patterns, function (pattern) {
    if (_.isString(pattern)) {
      return glob.sync(pattern, options);
    } else {
      if (_.isRegExp(pattern)) {
        return _.filter(glob.sync("**/*.*", options), function (filename) {
          return filename.match(pattern);
        });
      } else {
        return [];
      }
    }
  });
  if (options.filter) {
    matches = matches.filter(function (filepath) {
      filepath = path.join(options.cwd || "", filepath);
      try {
        if (_.isFunction(options.filter)) {
          return options.filter(filepath);
        } else {
          return fs.statSync(filepath)[options.filter]();
        }
      } catch (e) {
        return false;
      }
    });
  }
  return matches;
};
processPatterns = function (patterns, fn) {
  var result;
  result = [];
  _.flatten(patterns).forEach(function (pattern) {
    var exclusion, matches;
    exclusion = _.isString(pattern) && pattern.indexOf("!") === 0;
    if (exclusion) {
      pattern = pattern.slice(1);
    }
    matches = fn(pattern);
    if (exclusion) {
      return result = _.difference(result, matches);
    } else {
      return result = _.union(result, matches);
    }
  });
  return result;
};
module.exports = expand;
_.extend(expand, {
  glob: glob,
  VERSION: typeof VERSION !== "undefined" && VERSION !== null ? VERSION : "{NO_VERSION}"
});

;