// Generated by CoffeeScript 1.10.0
var Entities, _, blocks, cleanText, decodeHtmlEntities, delimitCode, getAttrList, getAttribute, getTextNodeContent, htmlEntities, isBlock, isVoid, ref, stringRepeat, voids,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Entities = require('html-entities').AllHtmlEntities;

_ = require('lodash');

blocks = require('./block-tags');

voids = require('./void-tags');

ref = require('./tree-adapter'), getAttrList = ref.getAttrList, getTextNodeContent = ref.getTextNodeContent;


/**
 * @param {String} x The string to be repeated
 * @param {String} n Number of times to repeat the string
 * @return {String} The result of repeating the string
 */

stringRepeat = function(x, n) {
  var s;
  s = '';
  while (true) {
    if (n & 1) {
      s += x;
    }
    n >>= 1;
    if (n) {
      x += x;
    } else {
      break;
    }
  }
  return s;
};


/**
 * Wrap code with delimiters
 * @param {String} code
 * @param {String} delimiter The delimiter to start with, additional backticks
   will be added if needed; like if the code contains a sequence of backticks
   that would end the code block prematurely.
 */

delimitCode = function(code, delimiter) {
  while (RegExp("([^`]|^)" + delimiter + "([^`]|$)").test(code)) {
    delimiter += '`';
  }
  if (code[0] === '`') {
    code = ' ' + code;
  }
  if (code.slice(-1) === '`') {
    code += ' ';
  }
  return delimiter + code + delimiter;
};

getAttribute = function(node, attribute) {
  var ref1;
  return ((ref1 = _.find(getAttrList(node), {
    name: attribute
  })) != null ? ref1.value : void 0) || null;
};

cleanText = function(node) {
  var parent, ref1, ref2, text;
  parent = node.parentNode;
  text = decodeHtmlEntities(getTextNodeContent(node));
  if ('pre' !== parent.tagName && 'pre' !== ((ref1 = parent.parentNode) != null ? ref1.tagName : void 0)) {
    text = text.replace(/\s+/g, ' ');
  }
  if ((ref2 = parent.tagName) === 'code' || ref2 === 'pre') {
    return text;
  } else {
    return text.replace(/\u2014/g, '--').replace(/\u2018|\u2019/g, '\'').replace(/\u201c|\u201d/g, '"').replace(/\u2026/g, '...');
  }
};

htmlEntities = new Entities();

decodeHtmlEntities = function(text) {
  return htmlEntities.decode(text);
};

isBlock = function(node) {
  var ref1, ref2;
  if (node.tagName === 'code' && ((ref1 = node.parentNode) != null ? ref1.tagName : void 0) === 'pre') {
    return true;
  } else {
    return ref2 = node.tagName, indexOf.call(blocks, ref2) >= 0;
  }
};

isVoid = function(node) {
  var ref1;
  return ref1 = node.tagName, indexOf.call(voids, ref1) >= 0;
};

module.exports = {
  cleanText: cleanText,
  decodeHtmlEntities: decodeHtmlEntities,
  delimitCode: delimitCode,
  getAttribute: getAttribute,
  isBlock: isBlock,
  isVoid: isVoid,
  stringRepeat: stringRepeat
};
