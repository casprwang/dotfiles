{"version":3,"sources":["../src/elementTree.js"],"names":[],"mappings":"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","file":"elementTree.js","sourcesContent":["/* @flow */\n\nimport * as babylon from 'babylon';\n\nimport type Program from './elements/types/Program';\nimport type Location from './elements/Element';\n\nimport visitorKeys from './visitorKeys';\nimport elementIndex from './elements/elementIndex';\nimport Token from './elements/Token';\n\nexport type BabylonToken = {\n    type: string,\n    value: string,\n    start: number,\n    end: number,\n    loc?: Location,\n    sourceCode: string\n};\n\n/**\n * Creates CST using AST and token list.\n *\n * @param {Object} ast\n * @param {Array} tokens\n * @returns {Program}\n */\nexport function buildElementTree(ast: Object, tokens: Array<BabylonToken>): Program {\n    var firstToken = tokens[0];\n    ast.start = firstToken.start;\n    ast.end = tokens[tokens.length - 1].end;\n    return ((buildElementTreeItem(ast, {\n        tokens,\n        token: firstToken,\n        pos: 0\n    }): any): Program);\n}\n\ntype ElementTreeItemState = {\n    tokens: Array<BabylonToken>,\n    token: BabylonToken,\n    pos: number\n};\n\n/**\n * @param {Object} ast\n * @param {{tokens: Array, token: Object, pos: Number}} state\n * @returns {Element}\n */\nfunction buildElementTreeItem(ast: Object, state: ElementTreeItemState): ?Element {\n    var elementType = ast.type;\n    let childProps = visitorKeys[elementType];\n\n    // Skip first `Identifier` for ({ test = 1 } = {})\n    // since it is already used in `AssignmentPattern`\n    // Need to fix this one day (See https://github.com/babel/babylon/issues/49)\n    if (\n        ast.type === 'ObjectProperty' &&\n        ast.value.type === 'AssignmentPattern'\n    ) {\n        delete ast.key;\n    }\n\n    if (!childProps) {\n        let error = new SyntaxError(`Cannot iterate using ${elementType}`);\n        error.loc = ast.loc.start;\n        throw error;\n    }\n\n    let childElements = [];\n    for (let i = 0; i < childProps.length; i++) {\n        let childAst = ast[childProps[i]];\n\n        if (!childAst) {\n            continue;\n        }\n\n        if (Array.isArray(childAst)) {\n            for (let j = 0; j < childAst.length; j++) {\n                if (childAst[j] === null) {\n                    continue;\n                }\n\n                childElements[childElements.length] = childAst[j];\n            }\n        } else {\n            childElements[childElements.length] = childAst;\n        }\n    }\n\n    childElements.sort((ast1, ast2) => {\n        return ast1.start < ast2.start ? -1 : (ast1.start > ast2.start ? 1 : 0);\n    });\n\n    let NodeClass = elementIndex[elementType];\n\n    if (!NodeClass) {\n        throw new Error(`Cannot create ${elementType} instance`);\n    }\n\n    let children = [];\n    let childElementIndex = 0;\n    let childElement = childElements[0];\n    let end = ast.end;\n\n    do {\n        if (childElement && state.token.start === childElement.start) {\n            if (state.token.end > childElement.end) {\n                let EmptyNodeClass = elementIndex[childElement.type];\n                if (!EmptyNodeClass) {\n                    throw new Error(`Cannot create ${childElement.type} instance`);\n                }\n\n                children[children.length] = new EmptyNodeClass([]);\n                childElement = childElements[++childElementIndex];\n            } else {\n                let nextChild = childElements[childElementIndex + 1];\n\n                children[children.length] = buildElementTreeItem(childElement, state);\n                childElement = childElements[++childElementIndex];\n\n                if (!state.token ||\n                    (state.token.start === end && (state.token.end !== end || elementType !== 'Program'))\n                ) {\n                    return new NodeClass(children);\n                }\n            }\n        } else {\n            let endOfAstReached = state.token.end === end;\n            let addedTokenType = state.token.type;\n\n            if (endOfAstReached && ast.type === 'Identifier' && addedTokenType === 'Keyword') {\n                state.token.type = addedTokenType = 'Identifier';\n            }\n\n            children[children.length] = Token.createFromToken(state.token);\n\n            state.pos++;\n            state.token = state.tokens[state.pos];\n\n            if (elementType === 'Program' && addedTokenType !== 'EOF') {\n                continue;\n            }\n\n            if (endOfAstReached) {\n                return new NodeClass(children);\n            }\n        }\n    } while (state.token);\n}\n\n/**\n * Build single token list using code tokens, comments and whitespace.\n *\n * @param {Array} codeTokens\n * @param {String} code\n * @returns {Array}\n */\nexport function buildTokenList(codeTokens: Array<BabylonToken>, code: string): Array<BabylonToken> {\n    let prevPos = 0;\n    let result = [];\n\n    for (var i = 0; i < codeTokens.length; i++) {\n        let token = processToken(codeTokens[i], code);\n\n        let pos = token.start;\n        if (prevPos !== pos) {\n            let value = code.substring(prevPos, pos);\n            result[result.length] = {\n                type: 'Whitespace',\n                value,\n                sourceCode: value,\n                start: prevPos,\n                end: pos\n            };\n        }\n        result[result.length] = token;\n\n        prevPos = token.end;\n    }\n\n    return result;\n}\n\n/**\n * Babylon token types.\n */\nlet tt = babylon.tokTypes;\n\n/**\n * Transforms Babylon-style token to Esprima-style token.\n *\n * @param {Object} token\n * @param {String} source\n */\nfunction processToken(token: Object, source: string): BabylonToken {\n    var type = token.type;\n\n    if (type === tt.name) {\n        token.type = 'Identifier';\n    } else if (type === tt.semi || type === tt.comma ||\n        type === tt.parenL || type === tt.parenR ||\n        type === tt.braceL || type === tt.braceR ||\n        type === tt.slash || type === tt.dot ||\n        type === tt.bracketL || type === tt.bracketR ||\n        type === tt.ellipsis || type === tt.arrow ||\n        type === tt.star || type === tt.incDec ||\n        type === tt.colon || type === tt.question ||\n        type === tt.backQuote ||\n        type === tt.dollarBraceL || type === tt.at ||\n        type === tt.logicalOR || type === tt.logicalAND ||\n        type === tt.bitwiseOR || type === tt.bitwiseXOR ||\n        type === tt.bitwiseAND || type === tt.equality ||\n        type === tt.relational || type === tt.bitShift ||\n        type === tt.plusMin || type === tt.modulo ||\n        type === tt.exponent || type === tt.prefix ||\n        type === tt.doubleColon ||\n        type.isAssign) {\n        token.type = 'Punctuator';\n        if (!token.value) {\n            token.sourceCode = token.value = type.label;\n        }\n    } else if (type === tt.template) {\n        token.type = 'Template';\n        token.sourceCode = token.value;\n    } else if (type === tt.jsxTagStart) {\n        token.type = 'Punctuator';\n        token.sourceCode = token.value = '<';\n    } else if (type === tt.jsxTagEnd) {\n        token.type = 'Punctuator';\n        token.sourceCode = token.value = '>';\n    } else if (type === tt.jsxName) {\n        token.type = 'JSXIdentifier';\n    } else if (type === tt.jsxText) {\n        token.type = 'JSXText';\n    } else if (type.keyword === 'null') {\n        token.type = 'Null';\n        token.value = null;\n    } else if (type.keyword === 'false' || type.keyword === 'true') {\n        token.type = 'Boolean';\n        token.value = type.keyword === 'true';\n    } else if (type.keyword) {\n        token.type = 'Keyword';\n    } else if (type === tt.num) {\n        token.type = 'Numeric';\n    } else if (type === tt.string) {\n        token.type = 'String';\n    } else if (type === tt.regexp) {\n        token.type = 'RegularExpression';\n    } else if (type === 'CommentLine') {\n        token.sourceCode = '//' + token.value;\n    } else if (type === 'CommentBlock') {\n        token.sourceCode = '/*' + token.value + '*/';\n    } else if (type === tt.eof) {\n        token.type = 'EOF';\n        token.sourceCode = token.value = '';\n    }\n\n    if (!('sourceCode' in token)) {\n        token.sourceCode = source.slice(token.start, token.end);\n    }\n\n    return token;\n}\n"]}