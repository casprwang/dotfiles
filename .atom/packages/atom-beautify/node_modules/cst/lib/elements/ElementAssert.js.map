{"version":3,"sources":["../../src/elements/ElementAssert.js"],"names":[],"mappings":"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","file":"ElementAssert.js","sourcesContent":["/* @flow */\n\nimport type Element from './Element';\n\n/**\n * Element assertion class.\n * Used in specific Node types to check children for syntax correctness.\n *\n */\nexport default class ElementAssert {\n    /**\n     * @param {Element[]} elements\n     */\n    constructor(elements: Array<Element>) {\n        this._elements = elements;\n\n        if (elements.length > 0) {\n            this._navigate(0);\n        }\n    }\n\n    _elements: Array<Element>;\n    currentElement: ?Element;\n    _position: number;\n\n    /**\n     * Asserts that the current element is a token.\n     * Can also check for token type and value.\n     *\n     * @param {String} [tokenType]\n     * @param {String|Object} [tokenValue] if object is given, checks if value of token exists as object key.\n     */\n    assertToken(tokenType: string, tokenValue: string | Object): void {\n        let {isToken, type, value} = this.currentElement || {};\n\n        if (!isToken) {\n            throw new Error(`Token expected but \"${type}\" found`);\n        }\n\n        if (arguments.length > 0 && type !== tokenType) {\n            throw new Error(`Expected token type \"${tokenType}\" but \"${type}\" found`);\n        }\n\n        if (arguments.length === 2) {\n            if (typeof tokenValue === 'object' && tokenValue !== null) {\n                if (!tokenValue[value]) {\n                    throw new Error(`Expected token value (${Object.keys(tokenValue).join(', ')}) but ${value} found`);\n                }\n            } else if (tokenValue !== value) {\n                throw new Error(`Expected token value \"${tokenValue}\" but ${value} found`);\n            }\n        }\n    }\n\n    /**\n     * Asserts that the current element is a node.\n     * Can also check for node type.\n     *\n     * @param {String} nodeType\n     */\n    assertNode(nodeType: string): void {\n        let {isNode, type} = this.currentElement || {};\n\n        if (!isNode) {\n            throw new Error(`Node expected but \"${type}\" found`);\n        }\n\n        if (arguments.length > 0 && type !== nodeType) {\n            throw new Error(`Expected node type \"${nodeType}\" but \"${type}\" found`);\n        }\n    }\n\n    /**\n     * Asserts that the current element is a node.\n     * Can also check if any of the node type are satisfied.\n     *\n     * @param {Array} nodeTypes\n     */\n    assertOneOfNode(nodeTypes: Array<string>): void {\n        let {isNode, type} = this.currentElement || {};\n\n        if (!isNode) {\n            throw new Error(`Node expected but \"${type}\" found`);\n        }\n\n        if (arguments.length > 0 && nodeTypes.indexOf(type) === -1) {\n            throw new Error(`Expected one of node types \"${nodeTypes}\" but \"${type}\" found`);\n        }\n    }\n\n    /**\n     * Asserts that the current element is an expression.\n     */\n    assertExpression(): void {\n        let {isExpression, type} = this.currentElement || {};\n\n        if (!isExpression) {\n            throw new Error(`Expression expected but \"${type}\" found`);\n        }\n    }\n\n    /**\n     * Asserts that the current element is an assignment.\n     */\n    assertAssignable(): void {\n        let {isAssignable, type} = this.currentElement || {};\n\n        if (!isAssignable) {\n            throw new Error(`Expected assignable expression but ${type} found.`);\n        }\n    }\n\n    /**\n     * Asserts that the current element is a pattern.\n     */\n    assertPattern(): void {\n        let {isPattern, type} = this.currentElement || {};\n\n        if (!isPattern) {\n            throw new Error(`Expected pattern but ${type} found.`);\n        }\n    }\n\n    /**\n     * Asserts that the current element is a statement.\n     */\n    assertStatement(): void {\n        let {isStatement, type} = this.currentElement || {};\n\n        if (!isStatement) {\n            throw new Error(`Statement expected but \"${type}\" found`);\n        }\n    }\n\n    /**\n     * Asserts that the current element is a statement.\n     */\n    assertModuleSpecifier(): void {\n        let {isModuleSpecifier, type} = this.currentElement || {};\n\n        if (!isModuleSpecifier) {\n            throw new Error(`ModuleSpecifier expected but \"${type}\" found`);\n        }\n    }\n\n    /**\n     * Asserts that the end of child list was reached.\n     */\n    assertEnd(): void {\n        if (this.currentElement !== undefined) {\n            let {type} = this.currentElement || {};\n            throw new Error(`Expected end of node list but \"${type}\" found`);\n        }\n    }\n\n    /**\n     * Checks if the current element is a token.\n     * Can also check for token type and value.\n     *\n     * @param {String} [tokenType]\n     * @param {String|Object} [tokenValue] if object is given, checks if value of token exists as object key.\n     * @returns {Boolean}\n     */\n    isToken(tokenType: string, tokenValue?: string | Object): boolean {\n        let {isToken, type, value} = this.currentElement || {};\n\n        if (!isToken || (arguments.length > 0 && type !== tokenType)) {\n            return false;\n        }\n\n        if (arguments.length === 2) {\n            if (typeof tokenValue === 'object' && tokenValue !== null) {\n                return Boolean(tokenValue[value]);\n            }\n            return tokenValue === value;\n        }\n\n        return true;\n    }\n\n    /**\n     * Checks if the current element is a node.\n     * Can also check for token type and value.\n     *\n     * @param {String} [nodeType]\n     * @returns {Boolean}\n     */\n    isNode(nodeType: string): boolean {\n        let {isNode, type} = this.currentElement || {};\n\n        return !(!isNode || (arguments.length > 0 && type !== nodeType));\n    }\n\n    /**\n     * Checks if the current element is a statement.\n     *\n     * @returns {Boolean}\n     */\n    isStatement(): boolean {\n        let {isStatement} = this.currentElement || {};\n\n        return isStatement;\n    }\n\n    /**\n     * Checks if current element is token (can also check type and value),\n     * returns current element and move pointer to the next element.\n     *\n     * @param {String} [tokenType]\n     * @param {String|Object} [tokenValue]\n     * @returns {Element|null}\n     */\n    passToken(tokenType: string, tokenValue?: string | Object): ?Element {\n        this.assertToken.apply(this, arguments);\n        let token = this.currentElement;\n        this.moveNext();\n        return token;\n    }\n\n    /**\n     * Checks if current element is a node (can also check type),\n     * returns current element and move pointer to the next element.\n     *\n     * @param {String} [nodeType]\n     * @returns {Element|null}\n     */\n    passNode(nodeType: string): ?Element {\n        this.assertNode.apply(this, arguments);\n        let node = this.currentElement;\n        this.moveNext();\n        return node;\n    }\n\n    /**\n     * Checks if current element is a node (can also check if any types are satisfied),\n     * returns current element and move pointer to the next element.\n     *\n     * @param {Array} [nodeTypes]\n     * @returns {Element|null}\n     */\n    passOneOfNode(nodeTypes: Array<string>): ?Element {\n        this.assertOneOfNode(nodeTypes);\n        let node = this.currentElement;\n        this.moveNext();\n        return node;\n    }\n\n    /**\n     * Checks if current element is an expression,\n     * returns current element and move pointer to the next element.\n     * Ignores parentheses.\n     *\n     * @returns {Element}\n     */\n    passExpression(): Element {\n        return this._passExpressionInParens(expression => expression.isExpression);\n    }\n\n    /**\n     * Checks if current element is an expression or whitespace\n     * returns current element and move pointer to the next element.\n     * Ignores parentheses.\n     *\n     * @returns {Element}\n     */\n    passExpressionOrWhitespace(): Element {\n        return this._passExpressionInParens(expression => expression.isExpression || expression.isWhitespace);\n    }\n\n    /**\n     * Checks if current element is an expression or super,\n     * returns current element and move pointer to the next element.\n     * Ignores parentheses.\n     *\n     * @returns {Element}\n     */\n    passExpressionOrSuper(): Element {\n        return this._passExpressionInParens(expression => expression.isExpression || expression.type === 'Super');\n    }\n\n    /**\n     * Checks if current element is an expression or SpreadElement,\n     * returns current element and move pointer to the next element.\n     * Ignores parentheses.\n     *\n     * @returns {Element}\n     */\n    passExpressionOrSpreadElement(): Element {\n        return this._passExpressionInParens(\n            expression => expression.isExpression || expression.type === 'SpreadElement');\n    }\n\n    /**\n     * Passes expression ignoring parentheses, returns element and move pointer to the next element.\n     *\n     * @param {Function} assertCallback\n     * @returns {Element}\n     * @private\n     */\n    _passExpressionInParens(assertCallback: Function): Element {\n        let openParens = 0;\n\n        while (this.currentElement.type === 'Punctuator' && this.currentElement.value === '(') {\n            openParens++;\n            this.moveNext();\n            this.skipNonCode();\n        }\n\n        let expression = this.currentElement;\n\n        if (!expression) {\n            throw new Error('Could not match an expression');\n        }\n\n        if (!assertCallback(expression)) {\n            throw new Error(`Expression expected but \"${expression.type}\" found`);\n        }\n\n        this.moveNext();\n\n        while (openParens--) {\n            this.skipNonCode();\n            this.assertToken('Punctuator', ')');\n            this.moveNext();\n        }\n\n        return expression;\n    }\n\n    /**\n     * Checks if current element is an assignable, returns current element and move pointer to the next element.\n     * Ignores parentheses.\n     *\n     * @returns {Element}\n     */\n    passAssignable(): Element {\n        return this._passExpressionInParens(expression => expression.isAssignable);\n    }\n\n    /**\n     * Checks if current element is a statement,\n     * returns current element and move pointer to the next element.\n     *\n     * @returns {Element}\n     */\n    passStatement(): Element {\n        this.assertStatement();\n        let result = this.currentElement;\n        this.moveNext();\n        if (!result) {\n            throw new Error('Could not match statement');\n        }\n        return result;\n    }\n\n    /**\n     * Checks if current element is a pattern,\n     * returns current element and move pointer to the next element.\n     *\n     * @returns {Element|null}\n     */\n    passPattern(): Element {\n        this.assertPattern();\n        let result = this.currentElement;\n        this.moveNext();\n        if (!result) {\n            throw new Error('Could not match pattern');\n        }\n        return result;\n    }\n\n    /**\n     * Checks if current element is a module specifier,\n     * returns current element and move pointer to the next element.\n     *\n     * @returns {Element|null}\n     */\n    passModuleSpecifier(): ?Element {\n        this.assertModuleSpecifier();\n        let result = this.currentElement;\n        this.moveNext();\n        return result;\n    }\n\n    /**\n     * Skips comments and whitespace.\n     */\n    skipNonCode() {\n        while (true) {\n            let {isCode} = this.currentElement || {};\n            if (isCode !== false) {\n                break;\n            }\n            this.moveNext();\n        }\n    }\n\n    /**\n     * Skips comments and whitespace on the same line.\n     */\n    skipSameLineNonCode() {\n        while (true) {\n            let {isCode} = this.currentElement || {};\n            if (isCode !== false) {\n                break;\n            }\n\n            if (this.currentElement && this.currentElement.getNewlineCount() > 0) {\n                break;\n            }\n\n            this.moveNext();\n        }\n    }\n\n    /**\n     * Skips a semicolon.\n     */\n    skipSemicolon() {\n        if (this.currentElement && this.currentElement.type === 'Punctuator' && this.currentElement.value === ';') {\n            this.moveNext();\n        }\n    }\n\n    /**\n     * Moves pointer (currentElement) to next element.\n     */\n    moveNext() {\n        this._navigate(this._position + 1);\n    }\n\n    /**\n     * Navigates to specified child position.\n     *\n     * @param {Number} position\n     * @private\n     */\n    _navigate(position: number) {\n        this._position = position;\n        this.currentElement = this._elements[position];\n        this.isEnd = this.currentElement === undefined;\n    }\n}\n"]}