{"version":3,"sources":["../../src/elements/Element.js"],"names":[],"mappings":"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","file":"Element.js","sourcesContent":["/* @flow */\n\nimport type Program from './types/Program';\nimport {getLines} from '../utils/lines';\nimport ElementAssert from './ElementAssert';\n\nexport type Position = {\n    line: number,\n    column: number\n};\n\nexport type Location = {\n    start: Position,\n    end: Position\n};\n\nexport type Range = [\n    number,\n    number\n];\n\n/**\n * Base class for Node, Token and Fragment.\n *\n * @name Element\n * @class\n * @abstract\n */\nexport default class Element {\n    /**\n     * @param {String} type\n     * @param {Element[]} children\n     */\n    constructor(type: string, children: Array<Element>) {\n        this.type = type;\n\n        this.firstChild = null;\n        this.lastChild = null;\n        this.parentElement = null;\n        this.nextSibling = null;\n        this.previousSibling = null;\n        this.childElements = [];\n\n        if (children) {\n            for (let i = 0; i < children.length; i++) {\n                if (children[i].parentElement) {\n                    throw new Error('Cannot add element to several parents');\n                }\n            }\n            this._setChildren(children);\n        }\n\n        this.isToken = false;\n        this.isWhitespace = false;\n        this.isCode = true;\n        this.isComment = false;\n        this.isNonCodeToken = this.isComment || this.isWhitespace;\n        this.isNode = false;\n        this.isStatement = false;\n        this.isPattern = false;\n        this.isAssignable = false;\n        this.isFragment = false;\n\n    }\n\n    type: string;\n    firstChild: ?Element;\n    lastChild: ?Element;\n    parentElement: ?Element;\n    nextSibling: ?Element;\n    previousSibling: ?Element;\n    childElements: Array<Element>;\n    _onSetParentElement: ?((parentElement: ?Element) => void);\n\n    isModuleSpecifier: boolean;\n\n    // ==== Traversing =================================================================================================\n\n    /**\n     * Owner Program for this element or null if element does not have Program in its parent hierarchy.\n     *\n     * @returns {Program}\n     */\n    getOwnerProgram(): Program {\n        let element = this;\n        while (element && !element._isProgram) {\n            element = element.parentElement;\n        }\n        return ((element: any): Program);\n    }\n\n    getNextToken() {\n        var element = this;\n        while (element) {\n            if (element.nextSibling) {\n                return element.nextSibling.getFirstToken();\n            }\n\n            element = element.parentElement;\n        }\n\n        return null;\n    }\n\n    getPreviousToken() {\n        var element = this;\n        while (element) {\n            if (element.previousSibling) {\n                return element.previousSibling.getLastToken();\n            }\n\n            element = element.parentElement;\n        }\n\n        return null;\n    }\n\n    /**\n     * Next token (non-whitespace and non-comment). Null if token was not found.\n     *\n     * @returns {Element|null}\n     */\n    getNextCodeToken(): ?Element {\n        let token = this.getNextToken();\n        while (token && !token.isCode) {\n            token = token.getNextToken();\n        }\n        return token;\n    }\n\n    /**\n     * Previous token (non-whitespace and non-comment). Null if token was not found.\n     *\n     * @returns {Element|null}\n     */\n    getPreviousCodeToken(): ?Element {\n        let token = this.getPreviousToken();\n        while (token && !token.isCode) {\n            token = token.getPreviousToken();\n        }\n        return token;\n    }\n\n    /**\n     * Next non-whitespace token. Null if token was not found.\n     *\n     * @returns {Element|null}\n     */\n    getNextNonWhitespaceToken(): ?Element {\n        let token = this.getNextToken();\n        while (token && token.isWhitespace) {\n            token = token.getNextToken();\n        }\n        return token;\n    }\n\n    /**\n     * Previous non-whitespace token. Null if token was not found.\n     *\n     * @returns {Element|null}\n     */\n    getPreviousNonWhitespaceToken(): ?Element {\n        let token = this.getPreviousToken();\n        while (token && token.isWhitespace) {\n            token = token.getPreviousToken();\n        }\n        return token;\n    }\n\n    /**\n     * First token inside element child tree.\n     *\n     * @returns {Element|null}\n     */\n    getFirstToken(): ?Element {\n        let element = this.firstChild;\n        while (element && !element.isToken) {\n            element = element.firstChild;\n        }\n        return element;\n    }\n\n    /**\n     * Last token inside element child tree.\n     *\n     * @returns {Element|null}\n     */\n    getLastToken(): ?Element {\n        let element = this.lastChild;\n        while (element && !element.isToken) {\n            element = element.lastChild;\n        }\n        return element;\n    }\n\n    /**\n     * Calculates and returns Element range.\n     *\n     * @returns {Number[]}\n     */\n    getRange(): Range {\n        let counter = 0;\n\n        let previous = this.getPreviousToken();\n        while (previous) {\n            counter += previous._sourceCodeLength;\n            previous = previous.getPreviousToken();\n        }\n\n        return [counter, counter + this.getSourceCodeLength()];\n    }\n\n    /**\n     * Calculates and returns Element loc.\n     *\n     * @returns {Object}\n     */\n    getLoc(): Location {\n        let prevToken = this.getPreviousToken();\n        let startColumn = 0;\n        let startLine = 1;\n        while (prevToken) {\n            let lines = prevToken._sourceCodeLines;\n            startColumn += lines[lines.length - 1].length;\n            if (lines.length > 1) {\n                while (prevToken) {\n                    startLine += prevToken.getNewlineCount();\n                    prevToken = prevToken.getPreviousToken();\n                }\n                break;\n            }\n            prevToken = prevToken.getPreviousToken();\n        }\n\n        let elementLines = this.getSourceCodeLines();\n        let endLine = startLine + elementLines.length - 1;\n        let endColumn = elementLines[elementLines.length - 1].length;\n\n        if (startLine === endLine) {\n            endColumn += startColumn;\n        }\n\n        return {\n            start: {\n                line: startLine,\n                column: startColumn\n            },\n            end: {\n                line: endLine,\n                column: endColumn\n            }\n        };\n    }\n\n    // ==== Source Code ================================================================================================\n\n    /**\n     * Generated source code length.\n     *\n     * @returns {Number}\n     */\n    getSourceCodeLength(): number {\n        let length = 0;\n        let child = this.firstChild;\n        while (child) {\n            length += child.getSourceCodeLength();\n            child = child.nextSibling;\n        }\n        return length;\n    }\n\n    /**\n     * Generated source code.\n     *\n     * @returns {String}\n     */\n    getSourceCode(): string {\n        let code = '';\n        let child = this.firstChild;\n\n        while (child) {\n            code += child.getSourceCode();\n            child = child.nextSibling;\n        }\n        return code;\n    }\n\n    /**\n     * Generated source code lines.\n     *\n     * @returns {String[]}\n     */\n    getSourceCodeLines(): Array<string> {\n        return getLines(this.getSourceCode());\n    }\n\n    /**\n     * Generated source code line break count.\n     *\n     * @returns {Number}\n     */\n    getNewlineCount(): number {\n        let count = 0;\n        let child = this.firstChild;\n        while (child) {\n            count += child.getNewlineCount();\n            child = child.nextSibling;\n        }\n        return count;\n    }\n\n    // ==== Child Element Manipulation =================================================================================\n\n    /**\n     * Removes specified element from the element child list.\n     *\n     * @param {Element} element\n     *\n     * @returns {Element}\n     */\n    removeChild(element: Element): Element {\n        if (element.parentElement !== this) {\n            throw new Error('The element to be removed is not a child of this element.');\n        }\n\n        let children = this.childElements.concat();\n        let elementIndex = children.indexOf(element);\n        children.splice(elementIndex, 1);\n\n        this._setChildren(children);\n\n        let ownerProgram = this.getOwnerProgram();\n        if (ownerProgram) {\n            ownerProgram._removeElementsFromProgram([element]);\n        }\n\n        setParentElement(element, null);\n\n        return element;\n    }\n\n    /**\n     * Removes element.\n     */\n    remove() {\n        if (!this.parentElement) {\n            return;\n        }\n\n        this.parentElement.removeChild(this);\n    }\n\n    /**\n     * Appends specified element to the end of the child list.\n     * Accepts multiple nodes using `Fragment`.\n     *\n     * @param {Element} newElement\n     */\n    appendChild(newElement: Element) {\n        let children: Element[];\n        let newElements: Element[];\n        if (newElement.isFragment) {\n            this._ensureCanAdoptFragment(newElement);\n            newElements = newElement.childElements;\n            children = this.childElements.concat(newElement.childElements);\n        } else {\n            if (newElement.parentElement) {\n                throw new Error('Remove element before adding again');\n            }\n            this._ensureCanAdopt(newElement);\n            newElements = [newElement];\n            children = this.childElements.concat(newElement);\n        }\n\n        this._setChildren(children);\n\n        if (newElements) {\n            let ownerProgram = this.getOwnerProgram();\n            if (ownerProgram) {\n                ownerProgram._addElementsToProgram(newElements);\n            }\n        }\n    }\n\n    /**\n     * Prepends specified element to the beginning of the child list.\n     * Accepts multiple nodes using `Fragment`.\n     *\n     * @param {Element} newElement\n     */\n    prependChild(newElement: Element) {\n        let children: Element[];\n        let newElements: Element[];\n        if (newElement.isFragment) {\n            this._ensureCanAdoptFragment(newElement);\n            newElements = newElement.childElements;\n            children = newElement.childElements.concat(this.childElements);\n        } else {\n            if (newElement.parentElement) {\n                throw new Error('Remove element before adding again');\n            }\n            this._ensureCanAdopt(newElement);\n            newElements = [newElement];\n            children = [newElement].concat(this.childElements);\n        }\n\n        this._setChildren(children);\n\n        if (newElements) {\n            let ownerProgram = this.getOwnerProgram();\n            if (ownerProgram) {\n                ownerProgram._addElementsToProgram(newElements);\n            }\n        }\n    }\n\n    /**\n     * Inserts specified element before specified reference child.\n     * Accepts multiple nodes using `Fragment`.\n     *\n     * @param {Element} newElement\n     * @param {Element} referenceChild\n     */\n    insertChildBefore(newElement: Element, referenceChild: Element) {\n        if (referenceChild.parentElement !== this) {\n            throw new Error('Invalid reference child');\n        }\n\n        let index = this.childElements.indexOf(referenceChild);\n        let childrenBefore = this.childElements.slice(0, index);\n        let childrenAfter = this.childElements.slice(index);\n\n        let children: Element[];\n        let newElements: Element[];\n        if (newElement.isFragment) {\n            this._ensureCanAdoptFragment(newElement);\n            newElements = newElement.childElements;\n            children = childrenBefore.concat(newElement.childElements, childrenAfter);\n        } else {\n            if (newElement.parentElement) {\n                throw new Error('Remove element before adding again');\n            }\n\n            this._ensureCanAdopt(newElement);\n            children = childrenBefore.concat(newElement, childrenAfter);\n            newElements = [newElement];\n        }\n\n        this._setChildren(children);\n\n        if (newElements) {\n            let ownerProgram = this.getOwnerProgram();\n            if (ownerProgram) {\n                ownerProgram._addElementsToProgram(newElements);\n            }\n        }\n    }\n\n    /**\n     * Replaces children from `firstRefChild` to `lastRefChild` with specified element.\n     * Accepts multiple replacement nodes using `Fragment`.\n     *\n     * @param {Element} newElement\n     * @param {Element} firstRefChild\n     * @param {Element} lastRefChild\n     */\n    replaceChildren(newElement: Element, firstRefChild: Element, lastRefChild: Element) {\n        if (!firstRefChild || firstRefChild.parentElement !== this) {\n            throw new Error('Invalid first reference child');\n        }\n\n        if (!lastRefChild || lastRefChild.parentElement !== this) {\n            throw new Error('Invalid last reference child');\n        }\n\n        let firstIndex = this.childElements.indexOf(firstRefChild);\n        let lastIndex = this.childElements.indexOf(lastRefChild);\n\n        if (firstIndex > lastIndex) {\n            throw new Error('Invalid reference children order');\n        }\n\n        let childrenBefore = this.childElements.slice(0, firstIndex);\n        let childrenAfter = this.childElements.slice(lastIndex + 1);\n        let replacedChildren = this.childElements.slice(firstIndex, lastIndex + 1);\n\n        let children: Element[];\n        let newElements: Element[];\n        if (newElement.isFragment) {\n            this._ensureCanAdoptFragment(newElement);\n            children = childrenBefore.concat(newElement.childElements, childrenAfter);\n            newElements = newElement.childElements;\n        } else {\n            if (newElement.parentElement) {\n                throw new Error('Remove element before adding again');\n            }\n\n            this._ensureCanAdopt(newElement);\n            children = childrenBefore.concat(newElement, childrenAfter);\n            newElements = [newElement];\n        }\n\n        this._setChildren(children);\n\n        let ownerProgram = this.getOwnerProgram();\n\n        if (ownerProgram) {\n            ownerProgram._removeElementsFromProgram(replacedChildren);\n        }\n\n        for (let i = 0; i < replacedChildren.length; i++) {\n            let replacedChild = replacedChildren[i];\n            replacedChild.previousSibling = null;\n            replacedChild.nextSibling = null;\n            setParentElement(replacedChild, null);\n        }\n\n        if (ownerProgram && newElements) {\n            ownerProgram._addElementsToProgram(newElements);\n        }\n    }\n\n    /**\n     * Removes children from `firstRefChild` to `lastRefChild` with specified element.\n     *\n     * @param {Element} firstRefChild\n     * @param {Element} lastRefChild\n     */\n    removeChildren(firstRefChild: Element, lastRefChild: Element) {\n        if (!firstRefChild || firstRefChild.parentElement !== this) {\n            throw new Error('Invalid first reference child');\n        }\n\n        if (!lastRefChild || lastRefChild.parentElement !== this) {\n            throw new Error('Invalid last reference child');\n        }\n\n        let firstIndex = this.childElements.indexOf(firstRefChild);\n        let lastIndex = this.childElements.indexOf(lastRefChild);\n\n        if (firstIndex > lastIndex) {\n            throw new Error('Invalid reference children order');\n        }\n\n        let children = this.childElements.slice(0, firstIndex).concat(this.childElements.slice(lastIndex + 1));\n        let removedChildren = this.childElements.slice(firstIndex, lastIndex + 1);\n\n        this._setChildren(children);\n\n        let ownerProgram = this.getOwnerProgram();\n\n        if (ownerProgram) {\n            ownerProgram._removeElementsFromProgram(removedChildren);\n        }\n\n        for (let i = 0; i < removedChildren.length; i++) {\n            let removedChild = removedChildren[i];\n            removedChild.previousSibling = null;\n            removedChild.nextSibling = null;\n            setParentElement(removedChild, null);\n        }\n    }\n\n    /**\n     * Replaces child with specified element.\n     * Accepts multiple replacement nodes using `Fragment`.\n     *\n     * @param {Element} newElement\n     * @param {Element} oldElement\n     */\n    replaceChild(newElement: Element, oldElement: Element) {\n        this.replaceChildren(newElement, oldElement, oldElement);\n    }\n\n    /**\n     * Returns array of child element from firstRefChild to lastRefChild (including reference children).\n     *\n     * @param {Element} firstRefChild\n     * @param {Element} lastRefChild\n     * @returns {Array}\n     */\n    getChildrenBetween(firstRefChild: Element, lastRefChild: Element): Array<Element> {\n        if (!firstRefChild || firstRefChild.parentElement !== this) {\n            throw new Error('Invalid first reference child');\n        }\n\n        if (!lastRefChild || lastRefChild.parentElement !== this) {\n            throw new Error('Invalid last reference child');\n        }\n\n        let firstIndex = this.childElements.indexOf(firstRefChild);\n        let lastIndex = this.childElements.indexOf(lastRefChild);\n\n        if (firstIndex > lastIndex) {\n            throw new Error('Invalid reference children order');\n        }\n\n        return this.childElements.slice(firstIndex, lastIndex + 1);\n    }\n\n    /**\n     * Makes sure specified child is not already one of the parents of this element.\n     * Throws error on failure.\n     *\n     * @param {Element} child\n     * @private\n     */\n    _ensureCanAdopt(child: Element) {\n        let element = this;\n        while (element) {\n            if (element === child) {\n                throw new Error('The new child element contains the parent.');\n            }\n            element = element.parentElement;\n        }\n    }\n\n    /**\n     * Calls _ensureCanAdopt for each fragment element.\n     *\n     * @param {Element} fragment\n     * @private\n     */\n    _ensureCanAdoptFragment(fragment: Element) {\n        let fragmentChild = fragment.firstChild;\n        while (fragmentChild) {\n            this._ensureCanAdopt(fragmentChild);\n            fragmentChild = fragmentChild.nextSibling;\n        }\n    }\n\n    /**\n     * Assigns new children. Runs element syntax assertions.\n     *\n     * @param {Element[]} newChildren\n     * @private\n     */\n    _setChildren(newChildren: Element[]) {\n        this._acceptChildren(new ElementAssert(newChildren));\n\n        if (newChildren.length > 0) {\n            let previousChild = newChildren[0];\n            this.firstChild = previousChild;\n            previousChild.previousSibling = null;\n            setParentElement(previousChild, this);\n            if (newChildren.length > 1) {\n                // TODO(flow): error with only `let child;`\n                let child = newChildren[1];\n                for (let i = 1; i < newChildren.length; i++) {\n                    child = newChildren[i];\n                    child.previousSibling = previousChild;\n                    setParentElement(child, this);\n                    previousChild.nextSibling = child;\n                    previousChild = child;\n                }\n                child.nextSibling = null;\n                this.lastChild = child;\n            } else {\n                previousChild.nextSibling = null;\n                this.lastChild = previousChild;\n            }\n        } else {\n            this.firstChild = this.lastChild = null;\n        }\n\n        this.childElements = newChildren;\n    }\n\n    /**\n     * Runs element syntax assertions. Should be implemented for every Node.\n     *\n     * @param {Object} children\n     * @abstract\n     */\n    _acceptChildren(children: ElementAssert): void {\n        // Override\n    }\n\n    /**\n     * Clones current Element structure.\n     *\n     * @returns {Element}\n     */\n    cloneElement(): Element {\n        let clonedChildren: Element[] = new Array(this.childElements.length);\n        for (let i = 0; i < clonedChildren.length; i++) {\n            clonedChildren[i] = this.childElements[i].cloneElement();\n        }\n        let objectToClone = ((this: any): ConcreteElement);\n        return new objectToClone.constructor(clonedChildren);\n    }\n}\n\n/**\n * Artificial class for correct flow behaviour.\n */\nclass ConcreteElement extends Element {\n    constructor(children: Element[]) {\n        super('ConcreteElement', children);\n    }\n}\n\nfunction setParentElement(element: Element, parentElement: ?Element) {\n    element.parentElement = parentElement;\n    if (element._onSetParentElement) {\n        element._onSetParentElement(parentElement);\n    }\n}\n"]}