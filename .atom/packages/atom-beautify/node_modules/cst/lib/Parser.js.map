{"version":3,"sources":["../src/Parser.js"],"names":[],"mappings":"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","file":"Parser.js","sourcesContent":["/* @flow */\n\nimport {parse} from 'babylon';\n\nimport type {BabylonToken} from './elementTree';\nimport type Program from './elements/types/Program';\nimport type Token from './elements/Token';\nimport {buildTokenList, buildElementTree} from './elementTree';\nimport type BasePlugin from './plugins/BasePlugin';\n\n/**\n * @typedef {Object} CSTParserOptions\n * @property {String} sourceType Type of parsed code: \"module\" or \"script\".\n * @property {Boolean} allowReturnOutsideFunction\n * @property {Boolean} allowImportExportEverywhere\n * @property {Boolean} allowSuperOutsideMethod\n * @property {CSTParserExperimentalFeatureOptions} experimentalFeatures\n * @property {CSTParserLanguageExtensionsOptions} languageExtensions\n */\n\n/**\n * @typedef {Object} CSTParserLanguageExtensionsOptions\n * @property {Boolean} jsx\n * @property {Boolean} flow\n */\n\n/**\n * @typedef {Object} CSTParserExperimentalFeatureOptions\n * @property {Boolean} 'flow'\n * @property {Boolean} 'jsx'\n * @property {Boolean} 'asyncFunctions'\n * @property {Boolean} 'asyncGenerators'\n * @property {Boolean} 'classConstructorCall'\n * @property {Boolean} 'classProperties'\n * @property {Boolean} 'decorators'\n * @property {Boolean} 'doExpressions'\n * @property {Boolean} 'exponentiationOperator'\n * @property {Boolean} 'exportExtensions'\n * @property {Boolean} 'functionBind'\n * @property {Boolean} 'objectRestSpread'\n * @property {Boolean} 'trailingFunctionCommas\n */\n\n// https://developer.apple.com/library/watchos/documentation/DeveloperTools/Conceptual/InstrumentsUserGuide/UIAutomation.html\nconst DIRECTIVE_APPLE_INSTRUMENTATION = {\n    type: 'AppleInstrumentationDirective',\n    regexp: /^#([^\\n]+)/gm\n};\n\n// https://www.chromium.org/developers/web-development-style-guide\nconst DIRECTIVE_GRIT = {\n    type: 'GritDirective',\n    regexp: /^\\s*<(\\/?\\s*(?:if|include)(?!\\w)[^]*?)>/gim\n};\n\n// checking for the options passed to the babel parse method\nexport type CSTParserOptions = {\n    sourceType: 'script' | 'module',\n    allowReturnOutsideFunction: boolean,\n    allowImportExportEverywhere: boolean,\n    allowSuperOutsideMethod: boolean,\n    languageExtensions: Object,\n    experimentalFeatures: Object,\n    strictMode: ?boolean,\n    plugins: BasePlugin[]\n};\n\n/**\n * CST Parser.\n */\nexport default class Parser {\n    /**\n     * @param {CSTParserOptions} options\n     */\n    constructor(options?: CSTParserOptions) {\n        this._options = {\n            sourceType: 'module',\n            strictMode: true,\n            experimentalFeatures: {\n                'flow': true,\n                'jsx': true,\n                'asyncFunctions': true,\n                'asyncGenerators': true,\n                'classConstructorCall': true,\n                'classProperties': true,\n                'decorators': true,\n                'doExpressions': true,\n                'exponentiationOperator': true,\n                'exportExtensions': true,\n                'functionBind': true,\n                'objectRestSpread': true,\n                'trailingFunctionCommas': true\n            },\n            languageExtensions: {\n                jsx: true,\n                flow: true\n            },\n            plugins: []\n        };\n\n        if (options) {\n            this.setOptions(options);\n        }\n    }\n\n    _options: CSTParserOptions;\n\n    /**\n     * @returns {CSTParserOptions}\n     */\n    getOptions(): CSTParserOptions {\n        return this._options;\n    }\n\n    /**\n     * @param {CSTParserOptions} newOptions\n     */\n    setOptions(newOptions: CSTParserOptions) {\n        var currentOptions = this._options;\n        var currentExperimentalFeatures = currentOptions.experimentalFeatures;\n        var currentLanguageExtensions = currentOptions.languageExtensions;\n        var newExperimentalFeatures = newOptions.experimentalFeatures;\n        var newLanguageExtensions = newOptions.languageExtensions;\n        this._options = {\n            ...currentOptions,\n            ...newOptions,\n            experimentalFeatures: {\n                ...currentExperimentalFeatures,\n                ...newExperimentalFeatures\n            },\n            languageExtensions: {\n                ...currentLanguageExtensions,\n                ...newLanguageExtensions\n            }\n        };\n    }\n\n    parse(code: string): Program {\n        let ast = this._parseAst(code);\n        let tokens = this._processTokens(ast, code);\n        let program = buildElementTree(ast, tokens);\n        let programPlugins = {};\n        let plugins = this._options.plugins;\n        for (let plugin of plugins) {\n            let api = plugin.createApiForProgram(program);\n            if (api) {\n                var pluginName = plugin.getPluginName();\n                if (pluginName in programPlugins) {\n                    throw new Error(`Plugin \"${pluginName}\" was already registered.`);\n                } else {\n                    programPlugins[pluginName] = api;\n                }\n            }\n        }\n\n        program._acceptPlugins(programPlugins);\n\n        return program;\n    }\n\n    _parseAst(code: string): Program {\n        let options = this._options;\n        let languageExtensions = options.languageExtensions;\n        let directiveInstances = {};\n        let hasDirectives = false;\n        let directiveTypes = [];\n\n        if (languageExtensions.appleInstrumentationDirectives) {\n            directiveTypes.push(DIRECTIVE_APPLE_INSTRUMENTATION);\n        }\n\n        if (languageExtensions.gritDirectives) {\n            directiveTypes.push(DIRECTIVE_GRIT);\n        }\n\n        for (let directive of directiveTypes) {\n            code = code.replace(directive.regexp, function(str, value, pos) {\n                hasDirectives = true;\n                directiveInstances[pos] = {\n                    type: directive.type, value\n                };\n\n                // Cut 4 characters to save correct line/column info for surrounding code\n                return '/*' + str.slice(4) + '*/';\n            });\n        }\n\n        let ast = parse(code, {\n            sourceType: options.sourceType,\n            strictMode: options.strictMode,\n            allowImportExportEverywhere: options.allowImportExportEverywhere,\n            allowReturnOutsideFunction: options.allowReturnOutsideFunction,\n            allowSuperOutsideMethod: options.allowSuperOutsideMethod,\n            plugins: [\n                ...Object.keys(options.experimentalFeatures),\n                ...Object.keys(options.languageExtensions)\n            ]\n        });\n\n        let program = ast.program;\n        program.tokens = ast.tokens;\n\n        if (hasDirectives) {\n            for (let token of program.tokens) {\n                let directiveInstance = directiveInstances[token.start];\n                if (directiveInstances[token.start]) {\n                    token.type = directiveInstance.type;\n                    token.value = directiveInstance.value;\n                }\n            }\n        }\n\n        if (code.substr(0, 2) === '#!') {\n            program.tokens[0].type = 'Hashbang';\n        }\n\n        return program;\n    }\n\n    _processTokens(ast: Object, code: string): Array<BabylonToken> {\n        return buildTokenList(ast.tokens, code);\n    }\n}\n"]}