{"version":3,"sources":["../../../src/plugins/scopes/Scope.js"],"names":[],"mappings":"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","file":"Scope.js","sourcesContent":["/* @flow */\n\nimport type Node from '../../elements/Node';\nimport Reference from './Reference';\nimport Variable from './Variable';\nimport {default as Definition, types, typeOrder} from './Definition';\nimport toArray from '../../utils/toArray';\n\nexport default class Scope {\n    constructor(scopeInfo: ScopeInfo) {\n        let {node, parentScope, isProgramScope, isFunctionScope, isClassScope, isArrowFunctionScope} = scopeInfo;\n\n        this.node = node;\n        this.parentScope = parentScope;\n        if (parentScope) {\n            parentScope.childScopes.push(this);\n            this._depth = parentScope._depth + 1;\n        } else {\n            this._depth = 0;\n        }\n        this.childScopes = [];\n        this._variables = new Map();\n        this._references = new Map();\n        this._isProgramScope = Boolean(isProgramScope);\n        this._isFunctionScope = Boolean(isFunctionScope);\n        this._isClassScope = Boolean(isClassScope);\n        this._isArrowFunctionScope = Boolean(isArrowFunctionScope);\n\n        if (isProgramScope) {\n            this._programReferences = new Map();\n            this._programDefinitions = new Map();\n        }\n    }\n\n    _isProgramScope: boolean;\n    _isFunctionScope: boolean;\n    _isClassScope: boolean;\n    _isArrowFunctionScope: boolean;\n    node: Node;\n    _depth: number;\n    parentScope: ?Scope;\n    childScopes: Scope[];\n    _variables: Map<string, Variable[]>;\n    _references: Map<string, Reference[]>;\n\n    _programReferences: Map<Node, Reference>;\n    _programDefinitions: Map<Node, Definition>;\n\n    _addVariable(variable: Variable) {\n        let variables = this._variables.get(variable.name);\n        if (variables) {\n            variables.push(variable);\n            variables.sort((variable1: Variable, variable2: Variable) => {\n                let typeOrder1 = typeOrder[variable1.type];\n                let typeOrder2 = typeOrder[variable2.type];\n                if (typeOrder1 > typeOrder2) {\n                    return 1;\n                }\n                if (typeOrder1 < typeOrder2) {\n                    return -1;\n                }\n                return 0;\n            });\n        } else {\n            this._variables.set(variable.name, [variable]);\n        }\n    }\n\n    _addDefinition(definitionInfo: DefinitionInfo) {\n        let {node, name, type} = definitionInfo;\n        if (type === types.Variable) {\n            if (!this._isFunctionScope && this.parentScope) {\n                this.parentScope._addDefinition(definitionInfo);\n                return;\n            }\n        }\n\n        let variables = this._variables.get(name) || [];\n        let variable: ?Variable;\n        for (let item of variables) {\n            if (item.type === type) {\n                variable = item;\n                break;\n            }\n        }\n\n        if (!variable) {\n            variable = new Variable({name, type, scope: this});\n            this._adjustReferencesOnVariableAdd(variable);\n            this._addVariable(variable);\n        }\n\n        let definition = new Definition({node, type, scope: this});\n\n        variable._addDefinition(definition);\n\n        let programScope = this._getProgramScope();\n        if (programScope) {\n            programScope._programDefinitions.set(node, definition);\n        }\n    }\n\n    _removeDefinition(definition: Definition) {\n        let variable = definition.variable;\n\n        variable._removeDefinition(definition);\n\n        if (\n            variable._definitions.size === 0 &&\n            (\n                variable.type === 'LetVariable' ||\n                variable.type === 'Constant' ||\n                variable.type === 'Variable' ||\n                variable.type === 'Parameter' ||\n                variable.type === 'SelfReference' ||\n                variable.type === 'CatchClauseError' ||\n                variable.type === 'ImportBinding'\n            )\n        ) {\n            removeVariable(variable);\n        }\n\n        let programScope = this._getProgramScope();\n        if (programScope) {\n            programScope._programDefinitions.delete(definition.node);\n        }\n    }\n\n    _adjustReferencesOnVariableAdd(variable: Variable) {\n        let depth = variable.scope._depth;\n        let references = this._references.get(variable.name);\n        if (references) {\n            for (let reference of references) {\n                let refVar = reference.variable;\n                let varDepth = refVar.scope._depth;\n                if (varDepth === depth) {\n                    if (typeOrder[variable.type] < typeOrder[refVar.type]) {\n                        refVar._transferReferences(variable);\n                        removeVariableIfRequired(refVar);\n                    }\n                } else if (varDepth < depth) {\n                    refVar._references.delete(reference);\n                    variable._addReference(reference);\n                    reference.variable = variable;\n                    removeVariableIfRequired(refVar);\n                }\n            }\n        }\n\n        for (let childScope of this.childScopes) {\n            childScope._adjustReferencesOnVariableAdd(variable);\n        }\n    }\n\n    _addReference(referenceInfo: ReferenceInfo) {\n        let {name} = referenceInfo;\n        let reference = new Reference({scope: this, ...referenceInfo});\n        this._assignReference(reference, name);\n        let references = this._references.get(name);\n        if (references) {\n            references.push(reference);\n        } else {\n            this._references.set(name, [reference]);\n        }\n\n        let programScope = this._getProgramScope();\n        if (programScope) {\n            programScope._programReferences.set(reference.node, reference);\n        }\n    }\n\n    _assignReference(reference: Reference, name: string) {\n        let currentScope = this;\n        do {\n            let variables = currentScope._variables.get(name);\n            if (variables) {\n                if (reference.type) {\n                    for (let variable of variables) {\n                        if (variable.type === reference.type) {\n                            variable._addReference(reference);\n                            return;\n                        }\n                    }\n                } else {\n                    variables[0]._addReference(reference);\n                    return;\n                }\n            }\n            if (!currentScope.parentScope) {\n                let globalVariable = new Variable({\n                    name, type: types.ImplicitGlobal, scope: currentScope\n                });\n                globalVariable._addReference(reference);\n                currentScope._addVariable(globalVariable);\n                return;\n            } else {\n                if (\n                    (\n                        (name === 'arguments' || name === 'this') &&\n                        currentScope._isFunctionScope &&\n                        !currentScope._isArrowFunctionScope &&\n                        !currentScope._isProgramScope\n                    ) ||\n                    (\n                        name === 'super' && currentScope._isClassScope\n                    )\n                ) {\n                    let builtInVariable = new Variable({\n                        name, type: types.BuiltIn, scope: currentScope\n                    });\n                    builtInVariable._addReference(reference);\n                    currentScope._addVariable(builtInVariable);\n                    return;\n                }\n                currentScope = currentScope.parentScope;\n            }\n        } while (true);\n    }\n\n    _removeReference(reference: Reference) {\n        let variable = reference.variable;\n        let name = variable.name;\n        let references = this._references.get(name);\n        if (references) {\n            let index = references.indexOf(reference);\n            if (index !== -1) {\n                references.splice(index, 1);\n            }\n        }\n        variable._removeReference(reference);\n        if (\n            variable._references.size === 0 &&\n            (\n                variable.type === 'ImplicitGlobal' ||\n                variable.type === 'BuiltIn'\n            )\n        ) {\n            removeVariable(variable);\n        }\n\n        let programScope = this._getProgramScope();\n        if (programScope) {\n            programScope._programReferences.delete(reference.node);\n        }\n    }\n\n    _getProgramScope(): ?Scope {\n        let scope = this;\n        while (scope && !scope._isProgramScope) {\n            scope = scope.parentScope;\n        }\n        return scope;\n    }\n\n    getVariables(): Variable[] {\n        return [].concat.apply([], toArray(this._variables.values()));\n    }\n\n    getReferences(): Reference[] {\n        return [].concat.apply([], toArray(this._references.values()));\n    }\n\n    destroy() {\n        let parentScope = this.parentScope;\n        if (parentScope) {\n            let scopeIndex = parentScope.childScopes.indexOf(this);\n            if (scopeIndex !== -1) {\n                parentScope.childScopes.splice(scopeIndex, 1);\n            }\n        }\n        this.getReferences().forEach(this._removeReference, this);\n    }\n}\n\nfunction removeVariableIfRequired(variable: Variable) {\n    if (variable._references.size === 0 && variable._definitions.size === 0) {\n        let variables = variable.scope._variables.get(variable.name);\n        if (variables) {\n            let index = variables.indexOf(variable);\n\n            if (index !== -1) {\n                variables.splice(index, 1);\n            }\n\n            if (variables.length === 0) {\n                variable.scope._variables.delete(variable.name);\n            }\n        }\n    }\n}\n\nfunction removeVariable(variable: Variable) {\n    let scope = variable.scope;\n    let variables = scope._variables.get(variable.name);\n\n    if (variables) {\n        let index = variables.indexOf(variable);\n        if (index !== -1) {\n            variables.splice(index, 1);\n            if (variables.length === 0) {\n                scope._variables.delete(variable.name);\n            }\n            for (var reference of variable._references) {\n                reference.scope._assignReference(reference, variable.name);\n            }\n        }\n    }\n}\n\nexport type ReferenceInfo = {\n    node: Node,\n    name: string,\n    read: boolean,\n    write: boolean,\n    type?: string\n};\n\nexport type DefinitionInfo = {\n    node: Node,\n    name: string,\n    type: string\n};\n\nexport type ScopeInfo = {\n    node: Node,\n    parentScope: ?Scope,\n    isProgramScope?: boolean,\n    isFunctionScope?: boolean,\n    isClassScope?: boolean,\n    isArrowFunctionScope?: boolean\n};\n"]}